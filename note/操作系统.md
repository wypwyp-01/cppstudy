https://www.nowcoder.com/discuss/353159072050520064牛客操作系统总结

http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#_2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98另一篇总结





[TOC]





### 基本概念

#### Linux操作系统的启动过程

**1. BIOS/UEFI 初始化**

- **作用**：系统上电后，执行固化在主板上的 BIOS 或 UEFI 固件。
- **主要任务**：
  - 检查硬件（POST）
  - 初始化 CPU、内存、设备

**2 引导加载程序**

**BIOS/UEFI**根据设置的启动设备（通常是硬盘）中的引导记录（bootloader）来**加载引导加载程序**。常用的引导加载程序有GRUB和Syslinux等。**它负责加载操作系统的内核，并将控制权交给内核。**

**3 内核初始化**

内核是操作系统的核心部分，它承担着管理硬件、执行程序和提供服务等任务。**内核被加载到内存后**，开始进行一系列初始化操作：

- 初始化阶段：内核**初始化核心的数据结构和基本的硬件设备驱动程序**，准备切换到更高级别的特权级。
- 挂载临时根文件系统

**4 启动第一个进程**

内核启动后，它会创建一个进程号为 1 的进程，这个进程通常是 init（在现代 Linux 系统中，init 通常是由 systemd 取代的）。init 是 Linux 系统中的第一个用户空间进程，它是所有其他用户空间进程的祖先，**负责整个系统的初始化和管理**。

**5 读取默认运行级别（Target），决定系统启动模式**

**6 启动系统服务**

系统进入用户空间后，Linux 会启动多个重要的系统服务和守护进程。这些服务包括：

- **网络服务**：配置网络接口，分配 IP 地址，启动 DNS 等服务，确保系统可以访问网络。
- **系统日志**：启动日志服务（如 [rsyslog](https://zhida.zhihu.com/search?content_id=254147810&content_type=Article&match_order=1&q=rsyslog&zhida_source=entity)），收集并保存系统日志，方便后续查看。
- **SSH 服务**：如果系统允许远程访问，[sshd](https://zhida.zhihu.com/search?content_id=254147810&content_type=Article&match_order=1&q=sshd&zhida_source=entity) 服务会被启动，允许用户通过 SSH 登录到系统。
- **定时任务**：启动定时任务管理器（如 [cron](https://zhida.zhihu.com/search?content_id=254147810&content_type=Article&match_order=1&q=cron&zhida_source=entity)），执行预定的自动化任务。



**7. 用户登录界面**

所有的系统服务启动完毕后，系统会进入可供用户交互的阶段。如果系统配置了图形界面，登录界面就会弹出；如果是命令行模式，系统会显示终端提示符等待用户登录。



#### 伙伴系统

主要思想：把内存按 2 的幂划分成一对对的“伙伴”，方便快速分配和合并，从而减少内存碎片。

**内存块大小为 2ⁿ（如 4KB、8KB、16KB...）**

**当需要分配一个内存块时**：

- 找到最小满足条件的 2ⁿ 大小
- 如果没有刚好匹配的，就从更大的块中拆出一个来

**释放时**：

- 查找它的“伙伴块”是否也空闲
- 如果是，就合并成更大的块（递归合并）



| 优点                | 描述                         |
| ------------------- | ---------------------------- |
| **分配/释放速度快** | 只需计算和查表，时间复杂度低 |
| **支持快速合并**    | 合法的块可以不断合并成更大块 |
| **减少碎片**        | 通过合并机制缓解外部碎片问题 |

| 缺点                   | 描述                                   |
| ---------------------- | -------------------------------------- |
| **不能按任意大小分配** | 只能分配 2ⁿ 大小的块，可能导致内部碎片 |
| **管理复杂性**         | 需要维护多个空闲块链表（每种大小一个） |





### malloc

#### malloc是如何分配内存的

实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。
**malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。**
**方式一：通过 brk() 系统调用从堆分配内存**
**方式二：通过 mmap() 系统调用在文件映射区域分配内存；**

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。

malloc() 源码里默认定义了一个阈值：
如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；



#### malloc分配的是物理内存吗？

**malloc() 分配的是虚拟内存。**
如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。
只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。





#### 为什么不全部使用mmap来申请内存

申请内存的操作应该避免频繁的系统调用，**如果都用 mmap 来分配内存，等于每次都要执行系统调用。**
另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是**每次 mmap 分配的虚拟地址都是缺页状态**的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。
也就是说，**频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。**



`brk` 调整的是进程的**堆顶指针**（即 heap 的末尾），形成一段**连续的虚拟内存区间**。

**当内存释放的时候，就缓存在内存池中。**
等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅**减少了系统调用的次数，也减少了缺页中断的次数**，这将大大降低 CPU 的消耗。

#### 为什么不全部使用 brk来申请内存

线程安全性差。多线程中共享堆顶指针，容易竞争

不适合大内存。一次性用 `mmap` 分配大块、更好控制释放、可映射文件或匿名内存

随着程序的运行，可能产生大量的小块的内存碎片。





#### free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？

是因为 malloc/free 背后的内存管理器会在用户分配的内存“前面”悄悄地保存这块内存的大小等元数据

拿到的指针 `p` 实际上指向的是用户区域的起始地址，而不是整块的最开头。

传进来的地址向前偏移一定的字节数，就可以读出内存块的大小。



#### free释放内存，会归还给操作系统吗

malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；
malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。



#### 什么是内核

内核是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。内核是应用程序连接硬件设备的桥梁，应用程序只需要和内核进行交互，无需关心硬件硬件的细节。



#### 什么是用户态和内核态

在计算机系统中，内存可以分为两大区域：**内核空间和用户空间**。这种划分主要用于保护系统稳定性和安全性。

当程序使⽤⽤户空间时，我们常说该程序在 **⽤户态** 执⾏，⽽当程序使内核空间时，程序则在 **内核态** 执⾏。

- 内核空间，是操作系统内核代码及其运行时数据结构所在的内存区域，拥有对系统所有资源的完全访问权限，如进程管理、内存管理、文件系统、网络堆栈等。
- ⽤户空间，是操作系统为应用程序（如用户运行的进程）分配的内存区域，用户空间中的进程不能直接访问硬件或内核数据结构，只能通过系统调用与内核通信。

#### 内核态用户态的切换

当应用程序**执行系统调用**时，**会产生中断，发生中断后，CPU执行中断处理程序 ，也就是开始执行内核程序**。内核处理完后，主动触发中断，回到用户态继续工作。

系统调用是应用程序请求操作系统内核提供服务的接口，如文件操作（如 open、read、write）、进程控制（如 fork、exec）、内存管理（如 mmap）等。

#### 切换的场景

- 异常：CPU在执行用户态的进程时，发生了一些没有预知的异常，此时系统会切换到处理该异常的相关代码处理异常，比如缺页异常等。
- 中断：一些外围设备完成用户的请求操作后，会向CPU发送相应的中断信号。
- 系统调用：比如fork()来创建一个新进程。



#### 什么是中断

中断（Interrupt）是指**CPU 在执行当前程序过程中，由于内部或外部事件的发生，暂时中止当前程序的执行，转而去处理事件的机制**。事件处理完成后，CPU 再恢复执行被中断的程序。

中断一般分为两大类：**外部中断** 和 **内部中断（异常）**，其中异常又可细分。

1. **外部中断（Hardware Interrupt）**

> 由外部设备发起，通过中断控制器通知 CPU。

| 类型     | 举例                             |
| -------- | -------------------------------- |
| I/O 中断 | 键盘敲击、鼠标点击、网络数据到达 |
| 时钟中断 | 定时器定时触发，用于进程切换等   |



------

**2. 内部中断（Exception / Trap）**

> 由当前程序运行过程中 **CPU 自动产生**，比如运行出错或系统调用。

| 子类              | 描述                                       | 举例                   |
| ----------------- | ------------------------------------------ | ---------------------- |
| **陷阱（Trap）**  | **正常**执行中主动触发，**处理完继续执行** | 系统调用、断点指令     |
| **故障（Fault）** | 出错但**可以修复**，处理完后**重试指令**   | 缺页异常、除 0 错误    |
| **终止（Abort）** | **严重错误**，无法恢复                     | 内存校验错误，非法操作 |



### 进程线程



#### 线程之间共享和不共享的数据：

不共享的：

| 项目                                                      | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| **线程栈**（Stack）                                       | 每个线程都有自己的独立栈空间（用来存局部变量、函数调用链等） |
| **程序计数器（PC）**                                      | 每个线程有自己的 PC，用来记录下一条将要执行的指令            |
| **寄存器上下文**                                          | 每个线程的寄存器内容不同，例如 RAX、RSP 等在切换时要保存/恢复 |
| **线程私有数据（TLS, Thread Local Storage）**线程描述信息 | 用于存储线程级别的变量，比如 `__thread` 关键字或 `thread_local` 变量 |

共享的：

- **虚拟地址空间（包括以下内容）**：
  - 代码段（text segment）
  - 全局变量和静态变量
  - 堆（heap）
- **打开的文件描述符表**
- **进程的工作目录、UID 等进程级属性**



#### 什么是进程和线程

进程（Process） 是指计算机中正在运行的一个程序实例。

📌 **举例**：你启动了一个 MySQL 数据库服务，这个运行着的服务就是一个 **MySQL 进程**。

线程是进程中的一个执行单元。一个进程可以包含多个线程，它们共享进程的地址空间和资源。比如内存空间、文件句柄、网络连接等。
 📌 **举例**：MySQL 进程中，可能有多个线程：

- 一个线程处理客户端 A 的查询语句；
- 另一个线程在处理客户端的连接；
- 还有一个线程在写日志或刷新缓存。

协程是比线程更轻量的存在，是一种在**用户态**由程序自己调度的并发方式。协程本质上是一个函数和运行状态的组合，但它可以在执行过程中挂起（yield/await），然后在需要时恢复执行。

📌 **举例**：在 Redis 这类单线程高性能数据库中，会通过协程来处理多个客户端请求，让任务之间看起来像“并发”执行，实际是**一个线程在多个任务之间快速切换**，比如：

- 当前处理 A 客户端的请求，遇到 IO 就挂起；
- 切到 B 客户端继续执行；
- 当 A 的 IO 完成后再切回来继续。



每个进程在独立的地址空间中运行，不会直接影响其他进程。线程共享同一个进程的内存空间、全局变量和文件描述符。

进程切换需要保存和恢复大量的上下文信息，代价较高。线程切换相对较轻量，因为线程共享进程的地址空间，只需要保存和恢复线程私有的数据。

线程的生命周期由进程控制，进程终止时，其所有线程也会终止。

#### 进程线程的区别

线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。

线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。

线程执行开销小，但不利于资源的管理和保护；而进程正相反。

进程是资源分配的基本单位，线程是调度的最小单位。协程由用户调度



资源占用，切换开销：进程线程协程   高中低



| 特性                           | 进程                         | 线程                             |
| ------------------------------ | ---------------------------- | -------------------------------- |
| 内存开销，上下文切换，创建销毁 | 高                           | 低                               |
| 地址空间                       | 独立                         | 共享                             |
| 通信                           | 需要 IPC 机制，开销较大      | 共享内存，直接通信               |
| 并发性                         | 低                           | 高                               |
| 崩溃影响                       | 一个进程崩溃不会影响其他进程 | 一个线程崩溃可能导致整个进程崩溃 |



#### join和detach

当前线程调用join的话，该线程会等待子线程运行结束再继续向下运行。

detach()  线程分离  在线程分离之后，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。但是主线程退出也会**一并销毁创建出的所有子线程**。



#### 线程的上下文切换

这还得看线程是不是属于同⼀个进程：

- 当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；
- **当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

所以，线程的上下⽂切换相⽐进程，开销要⼩很多。





#### 进程的状态

- 运⾏状态（*Runing*）：该时刻进程占⽤ CPU；
- 就绪状态（*Ready*）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
- 阻塞状态（*Blocked*）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它 CPU 控制权，它也⽆法运⾏；



![os-5df30631-ad7d-4c65-af20-50b7b615eca8](D:\study\c++\学习笔记\yuque\image\os-5df30631-ad7d-4c65-af20-50b7b615eca8.png)

当然，进程还有另外两个基本状态：

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

![os-ae17a9dc-f555-481a-ba4a-caca06120be7](D:\study\c++\学习笔记\yuque\image\os-ae17a9dc-f555-481a-ba4a-caca06120be7.png)

#### PCB（一个进程的资源主要包括什么）：

操作系统是使用进程控制块（PCB）来描述一个进程的。里面主要包括：

1. **进程描述信息：**
   - 进程标识符：进程ID、父进程ID（pid、ppid）
   - 用户标识符：进程归属的用户

2. **进程控制和管理信息：**
   - 进程当前的状态：就绪态、阻塞态、运行态
   - 进程的优先级

3. **资源配置清单：**
   - 页表，打开的文件描述符列表、所使用的I/O设备的信息

4. **CPU相关信息：**
   - CPU中各个寄存器的值







#### 上下文切换：

上下文切换是操作系统在多任务处理环境中，**将 CPU 从一个进程切换到另一个进程的过程**。通过让多个进程共享 CPU 资源，使系统能够并发执行多个任务。

步骤：

- 保存当前进程的上下文：操作系统保存当前进程的 CPU 寄存器，程序状态等关键信息。
- 选择下一个进程：调度程序选择下一个要执行的进程。
- 恢复上一个进程的上下文。
- 切换到下一个进程。

切换了什么（上下文包括什么？）：

程序计数器，CPU寄存器

页表

PCB



#### 僵尸进程 孤儿进程

> 孤儿进程是 **其父进程已经终止，但它本身还在运行** 的进程。

🧠 **为什么会出现？**

- 父进程先于子进程退出；
- 系统内核会自动把孤儿进程交给 **`init`（PID 1）进程** 管理；
- `init` 会周期性调用 `wait()` 来回收它们，避免产生僵尸进程。



> 僵尸进程是 **已经执行完毕（终止），但其父进程没有调用 `wait()` 或 `waitpid()` 来回收它的退出状态信息** 的子进程。

🧠 **为什么会出现？**

- 每个子进程退出时，内核会保留一份其退出信息（包括返回码、资源占用等）；
- 直到父进程通过 `wait()`/`waitpid()` 显式地读取这些信息为止；
- 在这之前，该子进程会以“僵尸”状态保留在系统中。

危害：

- **大量僵尸进程会耗尽系统的 PID 表**（每个进程都有唯一的 PID），导致无法创建新进程（系统资源耗尽）；
- 造成系统不稳定甚至崩溃。





**注意**

**僵尸进程不会导致子进程的资源（如 IO 设备、打开的文件、内存等）无法释放。**

------

✅ 为什么？

当子进程执行完毕（即退出）后，**内核会立即自动释放以下资源**：

| 资源类型                | 是否被释放   |
| ----------------------- | ------------ |
| 内存（堆栈、数据段）    | ✅ 立即释放   |
| 打开的文件描述符        | ✅ 立即释放   |
| 占用的 IO 设备          | ✅ 立即释放   |
| 信号处理器等            | ✅ 立即释放   |
| CPU 调度资源            | ✅ 立即释放   |
| 进程表项（PCB）的大部分 | ✅ 大部分释放 |



------

🚨 唯一**保留的部分**是：

内核会为这个已经终止的子进程**保留一小块信息**，包括：

- 进程 ID（PID）
- 退出状态（exit code）
- 运行时间等统计信息

这些信息被保存在内核的进程表中，**直到父进程调用 `wait()` 或 `waitpid()`** 来读取它们为止。



#### 守护进程

**守护进程（Daemon Process）** 是指在**后台运行、不直接与用户交互、用于提供系统服务或任务**的特殊进程。

守护进程的主要目标是**提供一种持续运行的服务**，通常用于**执行一些系统级任务**。例如，守护进程可以用于**管理网络服务、定时任务、系统监控、日志记录等**。它们通常作为系统的一部分，在操作系统启动时通过启动脚本或系统配置文件自动启动，并且在系统关闭前会被自动终止。





#### 进程调度算法

**先到先服务调度算法(FCFS，First Come, First Served)** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

- 非抢占
- 不会饥饿
- 对短作业不利

**短作业优先**

选择预计运行时间最短的进程优先执行。这种方式可以**减少平均等待时间和响应时间**，但缺点是很难准确预知进程的执行时间，并且可能因为短作业一直在执行，导致长作业持续被推迟执行。

**最短剩余时间优先**

这是短作业优先的一种改进形式，它是抢占式的。即如果一个新进程的预计执行时间比当前运行进程的剩余时间短，调度器将暂停当前的进程，并切换到新进程。这种方法也可以最小化平均等待时间，但同样面临预测执行时间的困难。

- 会饥饿
- 对长作业不利

**高响应比优先**

响应比 = （等待时间+要求服务时间）/ 要求服务时间



在每次调度时，先计算各个作业的响应比，选择响应比最高的作业进行服务。

总和考虑了等待时间和yujie运行时间

不会饥饿



**时间片轮转调度算法**

时间片轮转调度为每个进程分配一个固定的时间段，称为时间片，20-50ms，进程可以在这个时间片内运行。如果进程在时间片结束时还没有完成，它将被放回队列的末尾。时间片轮转是公平的调度方式，可以保证所有进程得到公平的 CPU 时间。



**优先级调度**

在这种调度方式中，每个进程都被分配一个优先级。CPU 首先分配给优先级最高的进程。优先级调度可以是非抢占式的或抢占式的。在非抢占式优先级调度中，进程一旦开始执行将一直运行直到完成；在抢占式优先级调度中，更高优先级的进程可以中断正在执行的低优先级进程。

**多级反馈队列**

是时间片轮转和高优先级调度的综合







#### 进程间通信

管道：就是内核里面的一串缓存。无格式的字节流数据。

**匿名管道**：半双工的通信方式，数据只能单向流动且只能在具有父子关系的进程中使用。



![image-20250223204002517](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250223204002517.png)



**有名管道**：半双工，可以在不相关的进程间通信。

```
[root@wyp01 ~]# mkfifo mypipe
[root@wyp01 ~]# echo "hello" > mypipe 

另开一个窗口
[root@wyp01 ~]# cat mypipe
hello
```

效率低，不适合进程间频繁地交换数据。



**消息队列**：**是保存在内核中的消息链表**。在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消
息体（数据块），消息体是⽤户⾃定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，
所以每个消息体都是固定⼤⼩的存储块，不像管道是⽆格式的字节流数据。

缺点：

- 消息的最大长度以及队列的长度有限制，不适合比较大的数据传输。

- 存在内核态到用户态的数据拷贝开销

优点：

- 有格式（相对于管道） 
- 消息由内核维护，即使进程崩溃也不会丢失。

**共享内存**：

- 不同进程拿出⾃⼰的⼀段虚拟地址空间，映射到相同的物理内存

- 进程可以直接读写内存中的数据，无需通过内核进行数据复制。



- 优点：最快的进程间通信方式。
- 缺点：需要额外的同步机制，避免进程间的竞争。

**信号量**：⼀个整型计数器，**实现进程间互斥和同步**，信号量+共享内存通常组合使⽤

P（-）V（+）操作，用于控制信号量，是原⼦操作；

- ⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需
  阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。
- 另⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进
  程，于是会唤醒阻塞队列的第一个进程；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

**信号**：通知接受进程某个事件已经发⽣；唯⼀的异步通信机制；kill -9 SIGKILL信号，ctrl + c     SIGINT信号

常用的信号：

- SIGHUP：当我们退出终端（Terminal）时，由该终端启动的所有进程都会接收到这个信号，默认动作为终止进程。
- **SIGINT：程序终止（interrupt）信号。按 `Ctrl+C` 时发出**，大家应该在操作终端时有过这种操作。
- SIGQUIT：和 SIGINT 类似，按 `Ctrl+\` 键将发出该信号。它会产生核心转储文件，将内存映像和程序运行时的状态记录下来。
- **SIGKILL：强制杀死进程，本信号不能被阻塞和忽略。**
- **SIGTERM：与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。**

**socket套接字**：不同主机上的进程间的通信。主要用于客户端和服务器通过网络进行通信。

缺点：速度慢

优点：可以与不同主机上的进程进行通信。





#### 互斥的概念：

- 临界区是访问共享资源的代码片段，一定不能给多线程同时执行。
- 一个线程在临界区执行时，其他线程应该被阻止进入临界区，等待临界区资源被释放。



#### 如何解决临界区冲突/临界区的调度规则？

▪ ①临界区空闲时，⼀次仅允许⼀个进程进⼊（加锁）

▪ ②其他试图进⼊的进程必须等待

▪ ③已经进⼊临界区的进程要在有限时间内退出

▪ ④如果不能进⼊临界区则应让出CPU，避免出现“忙等”现象（忙等：不断的测试循环代码中变量的值，占⽤处理机不释放）





#### 同步的概念：

进程之间需要相互配合的完成工作，各个进程的工作推进需要遵循一定的先后顺序。并发进程/线程在一些关键点上可能需要互相等待 互通消息。

如操作A应该在操作B之前进行。



#### 互斥的实现：

**加锁**：

任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对

临界资源的访问后再执⾏解锁操作，以释放该临界资源。

- 忙等待锁：当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为**⾃旋锁**。
-  无等待锁：当没获取到锁的时候，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU让给其他线程执⾏。

**信号量**：

信号量是操作系统提供的⼀种协调共享资源访问的⽅法。**通常表示资源的数量**，对应的变量是⼀个整型（sem）变量。



设置互斥信号量，初始值为1。0表示已加锁，1表示没有加锁。

进入临界区之前执行P操作。

执行完临界区之后执行V操作。



#### 同步的实现：

**信号量：**可把信号量视为一个具有整数值的变量，在它之上定义三个操作：

- 一个信号量可以初始化为非负数
- semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。
- semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。

两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。

在前操作之后执行V操作

在后操作之前执行P操作



**条件变量**





**消息传递：**

**消息传递的实际功能以一对原语的形式提供：**

- send(destination,message)
- receive(source,message)



| 工具/机制         | 属于        | 说明                                       |
| ----------------- | ----------- | ------------------------------------------ |
| 🔒 Mutex（互斥锁） | 互斥        | 最基础的互斥手段                           |
| 🔏 Read-Write Lock | 互斥        | 读多写少优化方案                           |
| 🔁 Semaphore       | 同步 & 互斥 | 计数器可实现访问数量控制，也可用于同步顺序 |
| 📶 Condition       | 同步        | 条件触发型同步，依赖某状态发生             |
| 🪧 Event           | 同步        | 常用于线程间通知                           |
| 🚧 Barrier         | 同步        | 等大家都到齐再继续，典型同步               |









#### **锁机制：**

互斥锁：互斥访问共享资源，任何时间，只有一个线程可以持有互斥锁。

- 加锁失败后，线程会释放CPU，给其他线程。
- 有两次上下文切换的成本，加锁失败时 和锁被释放时
- **如果你能确定被锁住的代码执⾏时间很短，就不应该⽤互斥锁，⽽应该选⽤⾃旋锁**

自旋锁：基于**忙等待**的锁，线程在获取不到锁时会一直轮询，直到锁被释放。

- 长时间占用CPU资源 自旋时间与被锁住代码的执行时间成正比

读写锁：允许多个线程同时读，只允许一个线程写。

- 适用于能区分读操作和写操作的场景

- 读优先锁 写优先锁 公平读写锁（队列）

**上面三种锁都属于悲观锁**



悲观锁：认为**多线程同时修改共享资源的概率⽐较⾼，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

乐观锁：**先修改共享资源，再验证这段时间内有没有发⽣冲突，如果出现同时修改的情况，就放弃本次操作。**（冲突概率低，加锁成本高的场景使用）。















#### **经典同步互斥问题：**

##### 生产者 消费者问题

![image-20250224110904911](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224110904911.png)

P操作顺序不能交换 V操作顺序可以交换

实现互斥的P操作一定要在实现同步的P操作之后。













##### 哲学家就餐问题



方案一：

![image-20250224111519292](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224111519292.png)

会死锁



方案二：在拿叉子前加一个互斥锁，放下叉子后释放锁。

![image-20250224111650215](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224111650215.png)

**只要有⼀个哲学家进⼊了「临界区」，也就是准备要拿叉⼦时，**

**其他哲学家都不能动，只有这位哲学家⽤完叉⼦了，才能轮到下⼀个哲学家进餐。**

每次只能一个哲学家进餐



方案三：**让偶数编号的哲学家「先拿左边的叉⼦后拿右边的叉⼦」，奇数编号的哲学家「先拿右边的叉⼦后拿左**

**边的叉⼦」。**

![image-20250224111958214](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224111958214.png)

即不会出现死锁，也可以两⼈同时进餐。



方案四：**⽤⼀个数组** **state** **来记录每⼀位哲学家在进程、思考还是饥**

**饿状态（正在试图拿叉⼦）。**

那么，**⼀个哲学家只有在两个邻居都没有进餐时，才可以进⼊进餐状态。**



同样不会出现死锁，也可以两⼈同时进餐。



##### 读者写者问题：

读者优先



写者优先



公平策略









#### 死锁的概念

在两个或者多个并发线程中，如果每个线程**持有某种资源**，而又**等待其它线程释放它或它们现在保持着的资源**，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无限期的阻塞、相互等待的一种状态。



两个或多个进程在争夺系统资源时，由于互相等待对方手里的资源而导致无法继续执行的状态。

#### 产生死锁的原因：

资源分配不当，系统资源不⾜

程序推进的顺序不合适

#### 死锁产生的条件

1.互斥条件：一个进程占用了某个资源，其他进程只能等待。
2.不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3.持有并等待条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4.循环等待条件：多个进程形成了一个循环等待资源的链，每一个进程都在等待下一个进程所持有的资源。



| 条件           | 解释                       | 怎么破坏                       |
| -------------- | -------------------------- | ------------------------------ |
| **互斥**       | 资源不能共享               | 设计成读写锁、无锁结构         |
| **占有且等待** | 拿着一个锁还要等另一个     | 避免嵌套锁，先申请所有锁再执行 |
| **不剥夺**     | 拿了锁的线程不能被强制抢走 | 实现超时回退、资源剥夺机制     |
| **循环等待**   | A等B，B等C，C等A           | 统一加锁顺序，编号加锁避免环路 |

------





假设有两个进程 P1 和 P2，以及两个资源 R1 和 R2，一个简单的死锁场景是这样的：

1. P1 持有资源 R1，并请求资源 R2。
2. P2 持有资源 R2，并请求资源 R1。

在这种情况下，发生死锁的步骤如下：

1. **互斥条件**：R1 和 R2 都只能被一个进程占用。
2. **持有并等待条件**：P1 持有 R1 并等待 R2，同时 P2 持有 R2 并等待 R1。
3. **不可剥夺条件**：R1 和 R2 都不能被强制从 P1 和 P2 中剥夺。
4. **循环等待条件**：P1 等待 P2 持有的 R2，而 P2 等待 P1 持有的 R1，形成一个循环。



#### 死锁的解决

产⽣死锁的有四个必要条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。

避免死锁，破坏其中的一个就可以。

**消除互斥条件**

这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。

**消除请求并持有条件**

消除这个条件的办法很简单，**就是一个线程一次请求其所需要的所有资源。**

**消除不可剥夺条件**

占用部分资源的线程进一步申请其他资源时，如果申请不到，可以**主动释放它占有的资源**，这样不可剥夺这个条件就破坏掉了。

**消除环路等待条件**

可以**靠按序申请资源来预防**。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。







⼀次性分配所有资源（破坏持有等待条件）

已经得到部分，但得不到其他，释放拥有的（破坏不可剥夺条件）

给每类资源赋予⼀个编号，每⼀个进程按编号递增的顺序请求资源（破坏环路等待条件）

#### 死锁的检测

**资源分配图**

 

⾸先为每个进程和每个资源指定⼀个唯⼀的号码

然后建⽴资源分配图

判断是否有环路



#### 解除死锁



| 方法                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ❌ **手动终止进程**       | 使用 `kill` / 任务管理器 / `Ctrl+C` 终止死锁程序。最直接的办法。 |
| 🔍 **定位并强制释放资源** | 某些系统能查出死锁资源（Linux: `lsof`, `pstack`, `gdb`），可尝试释放或修复状态。 |
| 🔁 **重启服务**           | 在不可控或线上环境中，经常是最快解决死锁的办法。             |
| 🧠 **使用死锁检测机制**   | 某些操作系统和数据库支持死锁检测并会中断某一方线程（如数据库事务）。 |

> 🧠 死锁一旦发生，靠代码“自我解除”通常是**不现实的**，只能靠“强制介入”或事先“防止”。

#### 银行家算法：

本质是设法保证系统动态分配资源后不会进入不安全状态，以避免可能产生的死锁。

当进程提出资源请求并且系统的资源满足此次请求时，系统将判断进行此次资源分配后会不会进入不安全状态。如果判断结果维安全，则给进程分配资源。否则不分配资源。

- 要求进程预先提出自己可能申请的最大资源数量。
- 系统拥有固定的资源数量。













### 内存管理

#### 堆和栈的区别

栈：系统自动分配，高地址向低地址

堆：程序员手动分配释放，低地址向高地址

https://blog.csdn.net/myqq1418/article/details/81584761

分配方式和存储内容：

栈：系统自动分配，函数调用语句下一条可执行语句的地址，函数的参数，函数局部变量。

堆：程序员自己申请和释放，存放动态分配的对象和数组

大小和效率：

- 大小较小，WIN下通常为2M。效率高。

- 大小通常较大，理论上可以使用整个系统的可用空间（受限于系统的内存管理策略等因素）。申请效率较低。

生命周期：

- 随函数调用自动创建和销毁（作用域内）
- 程序员控制。程序员手动申请后，需要手动释放。

管理方式：

- 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 用空闲链表进行管理。

#### 为什么有了堆，还要有栈？/为什么有了栈，还要有堆？

堆和栈各有其独特的特性和用途，它们的存在是为了解决不同的问题，满足程序在运行时对内存管理的不同需求。

栈虽然方便快速，但是不利于管理大的内存，不利于动态管理内存资源（有的数据需要在整个程序运行空间有效）

堆的申请和管理复杂，效率较低。需要手动管理数据的生存周期，容易造成内存泄漏。

#### 栈帧

**栈帧（Stack Frame）** 是函数调用时在 **栈内存** 中为该函数专门分配的一块空间，它用来保存函数执行时需要的**局部变量、参数、返回地址等信息**。

#### 函数调用过程中栈的变化详解

https://blog.csdn.net/u012218309/article/details/81669227

```c++
栈高地址
   ▲
   │
   │ 参数 b（传给 foo 的）
   │ 参数 a
   │ 返回地址 ← call foo 自动压入
   │ 保存的上一个 ebp（栈帧指针）
ebp→─────────────────────
   │ 局部变量 y
   │ 局部变量 x
esp→─────────────────────  ← 当前栈顶（低地址）

栈低地址


call指令做的事情：
函数调用语句的下一条语句的地址（返回地址）

函数的左括号和第一行代码之间的指令：
push ebp 上一个函数的ebp（栈底）入栈
mov ebp esp	调整ebp（栈底），指向当前栈帧的栈底
sub esp 4Ch	给函数开辟栈帧空间
初始化栈帧空间为0XCCCCCCCC

右括号之后的指令：
mov esp ebp	回退栈帧
pop ebp	ebp出栈并把值赋值给ebp（ebp回到上一个函数的栈底）（esp现在指向返回地址，也就是函数调用语句后面一条指令的地址）
ret	出栈并把出栈的内容放入CPU的PC寄存器里面

函数调用完之后的指令：
add esp 8	在调用 sum(a, b) 之后，释放压栈时用于传参的 8 字节空间（2 个参数 × 4 字节）
```





#### 栈溢出的情况

- 递归调用的深度过大
- 定义了过大的局部变量，尤其是数组
- 函数的嵌套调用
- 线程栈空间设置的过小

**缓冲区溢出**是指程序向缓冲区写入的数据超出了缓冲区的大小，导致覆盖了相邻的内存区域，包括栈空间中的返回地址等重要信息。如果攻击者能够控制这些覆盖的内容，可能会以覆盖返回地址，使其指向**恶意代码的地址**。







#### 静态存储区：

用于存储全局变量和静态变量。在整个程序的生命周期内保持存在，直到程序结束。

分为：

- **初始化数据区**：存储已初始化的全局变量和静态变量。
- **未初始化数据区（BSS Section）**：存储未初始化的全局变量和静态变量。

在程序启动时，静态存储区中的变量会被初始化。如果变量没有显式初始化，它们会被自动初始化为零（对于数值类型）或空指针（对于指针类型）。

![进程虚拟地址空间.drawio](C:\Users\wangyupeng\Downloads\进程虚拟地址空间.drawio.png)

#### 大端 小端

⽹络字节序：⼤端

主机字节序：⼩端

⼩端：低地址放低位 0x12345678 78 56 34 12

x86_64是⼩端

如何判断：

```c++
int main() {
	union {
		int n;
		char ch[4];
	} data;
	data.n = 0x04030201;
	//union下公⽤⼀段四字节地址空间，data.ch只占⼀个字节，⼩端情况下为01，⼤端情况
	std::cout << data.n << std::endl;
	cout << (int)data.ch[2] << endl;
	if (data.ch[0] == 1) {
		std::cout << "little" << endl;
	}
	else {
		std::cout << "big" << endl;
	}
	return 0;
}
```







#### 内存管理的几种机制

1. 分区管理
   是连续管理的一种，把内存分为几个大小固定的（固定分区分配）或者是不固定的（动态分区分配）块，每个进程占用其中一个。如果进程很小的话，会浪费大量的空间。已经淘汰。

2 分页管理

把内存分为若干个很小的页面（4KB），相对比分块的划分力度更大一些。提高内存利用率。减少碎片，页式管理通过页表完成逻辑地址和物理地址的转换。

3 分段管理

把虚拟地址空间分为几个大小不定的有实际意义的段，比如 main 函数段，局部变量段，通过管理段表来把逻辑地址转为物理地址。

4 段页式管理

结合了段式管理和页面管理的优点，把虚拟地址空间先分为若干个段，每个段又分为若干个页，也就是说段页式管理的段与段以及段的内部都是离散的。

#### 内存分段

程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属**性的，所以就⽤分段的形式把这些段分离出来。

内存分配原则：以段为单位进行分配，每个段在内存中占据连续空间，不同的段之间可以不相邻。



段表的组成：段号，段长（段的长度），基址（起始位置）。

虚拟地址的组成：段选择子（段号，特权级等标志位），段内偏移量

虚拟地址和物理地址的映射：

![image-20250326113843102](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250326113843102.png)

优点：方便按照逻辑模块实现信息的共享和保护



缺点：外部碎片。容易产生多个不连续的小的内存快，大的程序无法装入。

内存交换效率低。（解决外部碎片可以通过内存交换（紧凑），但是需要用到硬盘，硬盘速度慢）





#### 内存分页：

分页：把整个虚拟地址和物理地址分成一段段固定尺寸的大小，（页，每一页4KB）

虚拟地址和物理地址通过页表来映射。

![image-20250326115748419](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250326115748419.png)

虚拟地址：页号  页内偏移量

页表：页号，内存块号。





快表：依据是局部性原理，存放的是最近访问的页表项的副本。

引入快表后的地址映射过程：

![image-20250326120017087](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250326120017087.png)



两级（多级）页表：

单级页表存在的问题：

- 页表必须连续存放，因此当页表很大时，要占用很多连续的内存块。

- 没有必要让整个页表常驻内存，因为进程在一段时间内很可能只访问几个特定的页面。



二级页表：把一级页表再分页并 离散存储，再建立一张页表记录各个部分的存储位置。

![image-20250327174034625](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250327174034625.png)

引入二级页表后，地址结构变成：一级页号+二级页号+页内偏移量



解决整个页表必须常驻内存空间的问题：

![image-20250327174515499](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250327174515499.png)

如果某个以及页表的页表项没有被用到，就不需要创建这个页表项对应的二级页表了。可以在需要时才创建二级页表。



缺点：不方便按照逻辑模块实现信息的共享和保护。

优点：内存空间利用率高，不会产生外部碎片，只会产生少量内部碎片。



#### 分页和分段区别：

- 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
- 段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定
- 段向用户提供二维地址空间；页向用户提供的是一维地址空间
- 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。
- 分页的内存利用率高，不会产生外部碎片；而分段如果单段长度过大，为其分配很大的连续空间不方便，会产生外部碎片。

#### 段页式内存管理：



将分段和分页组合起来

- 先将程序划分为多个有实际意义的段
- 接着再把每个段划分为多个页，也就是分段划分出来的连续空间，再划分固定大小的页。

![img](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)

地址结构：段号，页号，页内偏移量

每个程序一张段表，每个段建立一张页表。



段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。



#### 外部碎片和内部碎片

外部碎片和内部碎片最主要的区别就是外部碎片的内存不属于任何进程，而内部碎片属于某个进程。

内部碎片：

当系统为程序分配内存时，**分配的内存空间大于程序实际需要的大小**，多出来的这部分空间不能被使用，称为内部碎片。

页式管理会产生内部碎片（因为固定大小4KB,但可能用了1KB），但不会产生外部碎片。

外部碎片：

多次内存分配和释放后，**内存中出现很多小的、不连续的可用空间**，这些空间总和虽然很大，但单个都不足以满足新程序的分配请求，这些零散空间称为外部碎片。

段式管理会产生外部碎片，但不会产生内部碎片（按需分配）。







#### 物理内存 虚拟内存

物理内存指的是计算机中实际存在的硬件内存。物理内存是计算机用于存储运行中程序和数据的实际内存资源，操作系统和应用程序最终都必须使用物理内存来执行。

虚拟内存是操作系统提供的一种内存管理技术，它使得应用程序认为自己有**连续的、独立的**内存空间，而实际上，这个虚拟内存可能部分存储在物理内存上，部分存储在 **磁盘（如硬盘的交换分区或页面文件）** 中。

虚拟内存的核心思想是通过硬件和操作系统的配合，为每个进程提供一个独立的、完整的虚拟地址空间，解决物理内存不足的问题。



①、每个进程都有自己的虚拟地址空间，虚拟内存使用的是逻辑地址，它与实际的物理内存地址不同，必须经过地址转换才能映射到物理内存。

②、操作系统通过 **页表（Page Table）** 将虚拟地址映射到物理地址。当程序访问某个虚拟地址时，CPU 会通过页表找到对应的物理地址。

③、操作系统将虚拟内存划分为若干个**页（Pages）**，每个页可以被映射到物理内存中的一个页面。如果物理内存不够，操作系统会将不常用的页暂时存储到磁盘的交换区（Swap）中，这个过程叫做页交换（Paging）。

虚拟内存的基础是局部性原理。



#### pagecache

我们都知道程序运⾏的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率

很⾼，于是我们可以⽤ **PageCache** **来缓存最近被访问的数据**，当空间不⾜时淘汰最久未被访问的缓存。

所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘

中读取，然后缓存 PageCache 中。

还有⼀点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转

到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是⾮常耗时的，为了降低它的

影响，**PageCache** **使⽤了「预读功能」**。

⽐如，假设 read ⽅法每次只会读 32 KB 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会

把其后⾯的 32～64 KB 也读取到 PageCache，这样后⾯读取 32～64 KB 的成本就很低，如果在 32～64

KB 淘汰出 PageCache 前，进程读取到它了，收益就⾮常⼤。

所以，PageCache 的优点主要是两个：

**缓存最近被访问的数据；**

**预读功能；**









#### 局部性原理：

时间局部性：

如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行。如果某个数据被访问过，不久之后该数据很可能再次被访问。

空间局部性：

一旦数据访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。













#### 请求分页式内存管理

建立在分页管理的基础之上，为了支持虚拟内存增加了**请求调页和页面置换**功能。其具体流程是这样的：
首先作业运行时，仅装入当前要执行的部分页面即可。
假如在运行的过程中，发现要请求的页面不在内存中，由操作系统负责将所需的页面从外存调入到内存中。然后继续执行程序。
如果发现在把页面调入内存时，内存已满，操作系统负责把不常用的页面置换出去，以便腾出空间装入新的页面。



页表要增加：状态位（是否已经调入内存）、修改位、访问字段。

#### 页面置换算法





#### 动态分区分配算法





#### 交换技术/交换空间

内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存，以释放内存空间

- 可优先换出阻塞进程。

- 通常在许多进程运行且内存紧张的时候进行，如许多进程发生缺页
- 磁盘分为文件区和对换区，对换区的IO速度比文件区更快

![image-20250509223309644](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250509223309644.png)



#### 抖动/颠簸现象

抖动/颠簸：刚刚换出的⻚⾯⻢上换⼊内存，刚刚换⼊的⻚⾯⻢上换出外存，频繁的⻚⾯调度

原因：进程频繁访问的⻚⾯数⽬⽐分配的物理快多

进程⼯作集：抖动影响效率，虚拟内存管理器将⼀定量的内存⻚驻留在内存中，根据进程⼯作集的大小，动态调整这个⻚⾯数量





#### 写时复制





#### MESI协议

**MESI 协议**（也称为 **缓存一致性协议**）是多核处理器中用于维持 **缓存一致性（Cache Coherency）** 的一种经典协议，全称是：

> **MESI = Modified、Exclusive、Shared、Invalid**

它是一个 **写入无效（write-invalidate）协议**，用于保证在多个 CPU 核心各自拥有缓存副本时，缓存数据的一致性。

**当某个 CPU 对某一缓存行执行写操作时，其他 CPU 中这块数据的副本将被标记为 “无效” (Invalid)。**

------

🔄 MESI 四种状态含义：

| 状态                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **M（Modified）已修改** | 当前缓存行已被修改，**是唯一副本**，数据与主内存不同，**必须写回内存**。 |
| **E（Exclusive）独占**  | 当前缓存行**是唯一副本**，但数据和主内存一致，还**未被修改**。 |
| **S（Shared）共享**     | 当前缓存行可能存在于**多个缓存中**，数据和主内存一致。       |
| **I（Invalid）无效**    | 当前缓存行无效，不能使用。                                   |



------

🧠 示例：两个 CPU 同时访问一段内存

假设有两个 CPU，分别有自己的 L1 缓存。

1. CPU1 读某地址的数据：加载后处于 **Exclusive** 状态。
2. CPU2 也读了同样地址：此时两个缓存都为 **Shared**。
3. CPU1 对该地址写入：它会将其他缓存的这块数据 **置为 Invalid**，自身状态变为 **Modified**。

这就避免了两个 CPU 同时操作同一数据而出现的不一致问题。

------

✅ 总结：

> **MESI 协议通过四种状态管理缓存行，有效避免了多核环境中因缓存副本不一致而引起的数据错误**，是现代处理器缓存一致性的核心机制之一。











### 文件系统：



#### 索引节点：

索引节点（**inode**，index node）是类 Unix 文件系统（如 ext4、XFS 等）中用于描述文件属性的一种数据结构。每个文件或目录在文件系统中都有一个对应的 inode，它存储的是文件的**元数据**，而不是文件名或文件内容。

------

一、inode 中包含的信息：

- **文件类型**（如普通文件、目录、符号链接等）
- **文件权限**（读/写/执行权限）
- **文件所有者**（用户 UID 和组 GID）
- **文件大小**
- **创建、修改、访问时间戳**
- **硬链接计数**（指向该 inode 的目录项数量）
- **数据块指针**（即实际存储文件内容的磁盘块地址）

```
目录项
+------------+----------+
| 文件名     | inode号  |
+------------+----------+
      ↓
   inode表
+--------+------------------------+
| inode号 | 文件属性、数据块指针等 |
+--------+------------------------+
      ↓
   数据块（存储实际内容）
```



#### 硬链接  软链接

文件系统中两种实现“文件别名”的方式，它们都能让**一个文件有多个路径**，但工作原理和用途有明显区别。

硬链接：多个目录项中的**索引节点指针**（inode 指针）指向同一个 inode（**索引节点**）

- 依赖于索引节点，每个文件系统都有自己的索引节点，所以**硬链接不能跨文件系统**
- 删除任意一个硬链接不会影响其他链接和数据，**只有最后一个被删除时数据才会被释放**。
- **不能对目录创建硬链接**（为防止循环引用）。

软链接：

软链接是**一个特殊的文件，内容是另一个文件的路径名**。
 它相当于**快捷方式**

- 可以跨文件系统
- 如果原始文件被删除或移动，软链接会失效，称为“悬挂链接”
- 可以链接目录

![image-20250515221102068](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250515221102068.png)





#### Linux常用命令

目录相关

ls	cd	pwd	mkdir	rmdir	rm	cp	mv

查看文件内容

cat	head	tail	more	less

查找

find	grep

进程

ps aux	ps -ef

磁盘相关

df	du

网络相关

netstat	ping	ifconfig

压缩解压

zip	unzip	gzip	gunzip

其他

top	chmod	touch





































