

### 总体性问题

参考：https://mp.weixin.qq.com/s?__biz=Mzg4NTcyNjczNg==&mid=2247504325&idx=1&sn=2cc2214ec7613ca281d7bf1a6e786b12&source=41#wechat_redirect（moom聊技术）

#### [说说 OSI 七层模型？](https://javabetter.cn/sidebar/sanfene/network.html#说说-osi-七层模型)

OSI（Open System Interconnection）七层参考模型是一个网络架构模型，由国际标准化组织（ISO）提出，用于描述和标准化各种计算机网络的功能和过程。这七层从高到低分别是：

- **应用层**：**最靠近用户的层，专注于为⽤户提供应⽤功能，不关⼼数据如何传输，工作在用户态。**例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。
- **表示层**：确保从一个系统发送的信息可以被另一个系统的应用层读取。**它负责数据的转换、压缩和加密。**例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。
- **会话层**：**管理用户的会话，控制网络上两节点间的对话和数据交换的管理。它负责两点之间建立、维护和终止会话**。例如，建立一个会话令牌，以便在网络上的两个节点之间传递。
- **传输层**：**提供端到端的通信服务，保证数据的完整性和正确顺序**。这一层包括 TCP 和 UDP 等。
- **网络层**：**负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到从源到目的地的最佳路径。**这层使用的是 IP（Internet Protocol）协议。
- **数据链路层**：**在物理连接中提供可靠的传输，负责建立和维护两个相邻节点间的链路。**包括帧同步、MAC（媒体访问控制）。
- **物理层**：**负责在物理媒介上实现原始的数据传输**，比如电缆、光纤和无线信号传输。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。

#### TCP IP四层模型

①、**应用层（Application Layer）**：**直接面向用户和应用程序，提供各种网络服务。**它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。

示例：当在浏览器中输入一个 URL 并访问一个网页时，浏览器使用 HTTP 协议从 Web 服务器请求页面内容。

②、**传输层（Transport Layer）**：**提供端到端的通信服务，确保数据可靠传输。**它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。

示例：当发送一封电子邮件时，TCP 协议确保邮件从你的客户端可靠地传输到邮件服务器。

③、**网际层**：或者叫网络层（Internet Layer），**负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。**用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。

常见协议：IPv4、IPv6、ICMP（Internet Control Message Protocol）。

示例：当访问一个网站时，网络层协议（如 IPv4）将你的请求从你的计算机通过多个路由器传输到目标服务器。

④、**网络接口层（Network Access Layer）**：**或者叫链路层（Link Layer），负责将数字信号在物理通道（网线）中准确传输**，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。



#### 五层网络模型

- 应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。
- 传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。
- 网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。
- 数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。
- 物理层：电缆、光纤、无线电频谱、网络适配器等。



#### 每⼀层传输的基本数据单元

在一个典型的五层网络模型中（即应用层、传输层、网络层、数据链路层、物理层），每一层传输的基本数据单元（PDU，Protocol Data Unit）如下所示：

| 网络层级 | 层名       | 基本数据单元（PDU）                         |
| -------- | ---------- | ------------------------------------------- |
| 第五层   | 应用层     | 报文（Message）                             |
| 第四层   | 传输层     | 段（Segment，TCP）或数据报（Datagram，UDP） |
| 第三层   | 网络层     | 分组（Packet）                              |
| 第二层   | 数据链路层 | 帧（Frame）                                 |
| 第一层   | 物理层     | 比特（Bit）                                 |

#### 每一层常见的协议

![各层网络对应的网络协议](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg)

#### 为什么要分层





#### 数据在各层之间是怎么传输的





#### HTTP请求的完整过程

域名解析-->发起TCP的3次握⼿-->建⽴TCP连接后发起http请求-->服务器响应http请求，浏览器得到html代码

-->浏览器解析html代码，并请求html代码中的资源（如js、 css、图⽚等）-->浏览器对⻚⾯进⾏渲染呈现给⽤⼾

#### [从浏览器地址栏输入 url 到显示网页的过程了解吗？](https://javabetter.cn/sidebar/sanfene/network.html#_4-从浏览器地址栏输入-url-到显示网页的过程了解吗)

1 浏览器解析URL，并生成http请求信息

2 **DNS 解析**：浏览器会发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址

3 **TCP 连接**：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。

4 **发送 HTTP 请求**：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。

HTTP请求报文经过TCP/IP协议栈的处理，由网卡发送给服务端。

服务端收到请求的数据包后，经过TCP/IP协议栈的处理，交给对应的应用程序。

5 **服务器处理请求**：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。

6 **浏览器接收 HTTP 响应**：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。

7 **断开连接**：TCP 四次挥手，连接结束。





#### 这个过程如何加速

可以从协议优化、资源压缩、CDN 加速、前端优化、缓存机制等多个方面入手。



**例如使用 HTTP/3 减少握手延迟，**

**开启 Gzip 和 WebP 压缩减少传输体积，**

**利用 CDN 靠近用户分发资源，**

**前端使用懒加载、预加载等技术加快页面渲染，**

**同时通过缓存减少重复请求。**



这些都能有效加快从输入 URL 到页面呈现的整体速度。

#### 如何优化HTTP/1.1

避免发送HTTP请求

- 缓存

减少发送HTTP请求次数

- 合并请求（合并资源）
- 减少重定向次数
- 减少发送请求（当前不需要的资源没必要立刻发送请求）

减少HTTP响应数据

- 无损压缩
- 有损压缩

不管怎么优化都是有限的，所以才会出现HTTP/2 3

#### 网卡 交换机 路由器工作层次和基本原理

网卡：

**工作层次**：**物理层 + 数据链路层**

**主要功能**：

- 通过硬件与驱动程序实现如 **802.3（Ethernet）**、**802.11（Wi-Fi）** 等协议，实现数据的发送与接收
- 完成**物理信号的收发**以及**帧的封装/解封装**；
- 与操作系统之间通过 **I/O 中断** 和 **DMA（直接内存访问）** 实现高速数据交互；

交换机：

- **工作层次**：**数据链路层**
- **基本原理**：
  - 依据 **MAC 地址** 进行转发；
  - 维护 **MAC 地址表**（MAC → 端口）；
  - 实现局域网内部通信，**隔离冲突域**；
  - 不具备防火墙等安全能力，主要用于**内部网络通信优化**。

路由器：

**工作层次**：**网络层**

**基本原理**：

- 根据 **IP 地址** 进行路径选择；
- 转发不同网络（如不同子网、LAN 与 WAN）之间的数据包；
- 提供 **防火墙、安全策略、端口转发**等高级网络功能；
- 是连接互联网的关键设备，属于**三层设备**。

#### 影响网络带宽的因素





#### websocket与socket的区别



#### 常见的端口及对应的服务

| 端口号 | 协议 | 对应服务            |
| ------ | ---- | ------------------- |
| 20     | TCP  | FTP 数据传输        |
| 21     | TCP  | FTP 控制连接        |
| 22     | TCP  | SSH 远程登录        |
| 80     | TCP  | HTTP 超文本传输协议 |
| 443    | TCP  | HTTPS 安全HTTP      |
| 3306   | TCP  | MYSQL数据库         |
| 6379   | TCP  | Redis键值数据库     |





#### 常见的应用层协议

- HTTP/HTTPS（超文本传输协议/安全超文本传输协议）
- FTP（文件传输协议）
- SMTP（简单邮件传输协议）
- POP3/IMAP（邮局协议第3版/互联网消息访问协议）
- DNS（域名系统）
- SSH（安全外壳协议）



### HTTP

#### HTTP是什么

超⽂本（不仅是⽂字，还有图⽚、视频、音频、链接）、传输（双向协议、两点之间传输数据）、协议（约定和规范）

**HTTP** **是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。**





#### HTTP常见状态码

![image-20250224200228382](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224200228382.png)

- 200OK 最常见的成功状态码，表示一切正常

- 301永久重定向，请求的资源已经不存在，需要使用新的URL进行访问

- 302 表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

- 「**304 Not Modified**」，表示资源未修改，缓存重定向



- 「**400 Bad Request**」表示客户端请求的报⽂有错误，但只是个笼统的错误。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。
- **408 Request Timeout** ：请求超时。客户端请求时间过长，服务器等待超时。



- 「**500 Internal Server Error**」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。

- **501 Not Implemented** ：服务器不支持请求的功能。比如客户端请求了一个服务器不支持的HTTP方法。

- 「**503 Service Unavailable**」表示服务器当前很忙，暂时⽆法响应客户端，类似“⽹络服务正忙，请稍后再试”的意思。




#### HTTP常见字段：

- *Host* 字段    客户端发送请求时，⽤来指定服务器的域名。有了 Host 字段，就可以将请求发往「同⼀台」服务器上的不同⽹站。

- *Connection* 字段 Connection 字段最常⽤于客户端要求服务器使⽤「**HTTP ⻓连接**」机制。只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。



与请求体、响应体相关：

- *Content-Length* 字段 表示本次回应的数据长度
- *Content-Type* 字段  Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。

```
Content-Type:text/html;charset = UTF-8
```

- *Content-Encoding* 字段  Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式
- Content-Language：使用的自然语言



缓存相关：



Cookie相关：



#### HTTP常见的请求方法

GET从服务器获取指定的资源

POST用于向服务器提交数据

PUT用于更新指定的资源

DELETE删除指定的资源



#### GET  POST区别

**用处  位置  格式  长度  安全和幂等  缓存**

**GET** **的语义是从服务器获取指定的资源**，这个资源可以是静态的⽂本、⻚⾯、图⽚视频

等。**GET 请求的参数位置⼀般是写在 URL 中**，URL 规定只能⽀持 ASCII，所以 GET 请求的**参数只允许**

**ASCII 字符** ，⽽且**浏览器会对 URL 的⻓度有限制**（HTTP协议本身对 URL⻓度并没有做任何规定）。

**GET** **⽅法是安全且幂等的** ，可以对GET请求的数据做缓存。**⽽且在浏览器中** **GET** **请求可以保**

**存为书签**。



**POST** **的语义是将数据提交到服务器**，数据的位置⼀般是写在**报⽂ body 中**，body 中的数据**可以是任意格式的**

资源类型⽽不同。POST 请求携带数据的位置⼀般是写在报⽂ body 中，body 中的数据可以是任意格式的

**数据**，只要客户端与服务端协商好即可，⽽且**浏览器不会对 body ⼤⼩做限制**。

**POST** **不是安全和幂等**的。所以，**浏览器⼀般不会缓存** **POST** **请求，也不能把POST请求保存为书签**。



安全和幂等的概念：

在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。

所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。





#### HTTP缓存

什么是缓存：对于一些重复性的HTTP请求，每次得到的数据都是一样的，可以吧这对请求-响应缓存在本地，以后直接使用本地数据。

**强缓存**：只要浏览器判断缓存没有过期，则直接使⽤浏览器的本地缓存，决定是否使⽤缓存的主动性在于浏览器这边。

Cache-Control ， 是⼀个相对时间；

Expires ，是⼀个绝对时间；

当浏览器第⼀次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上Cache-Control，Cache-Control 中设置了过期时间⼤⼩；

浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与** **Cache-Control** **中设置的过**

**期时间⼤⼩，来计算出该资源是否过期**，如果没有，则使⽤该缓存，否则重新请求服务器；

服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。



**协商缓存**：

**与服务器协商之后，通过协商结果来判断是否使用本地缓存。**

ETag和If-None-Match：ETag⽤来判断是否改变，给服务器发的时候ETag在If-None

Match⾥

Last-Modified和If-Modified-Since：Last-Modified是最后⼀次改变时间，Last

Modified放在If-Modified-Since⾥



- etag优先级更高
- etag性能上低，精度上高
- 只有没有命中强缓存，才会进行协商缓存。





#### HTTP请求/响应报⽂格式

▪ 请求：请求头（请求⽅法+URI协议+版本） + 请求⾸部 + 空⾏ + 请求主体

▪ 响应：状态⾏ （版本+状态码+原因短语）+ 响应⾸部 + 空⾏ + 响应主体

请求报文格式：

![image-20250224212716491](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224212716491.png)

响应报文格式：

![image-20250224212801573](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224212801573.png)













#### HTTP/1.0缺点

短连接⽆状态，每次三次握⼿四次挥⼿

第⼀个请求发出去必须等确认回来，才能发第⼆个请求（队头阻塞）



#### HTTP/1.1优点

简单  灵活易于扩展  应用广泛跨平台

长连接 （只要任意一端没有明确提出断开连接，就保持TCP连接）

管道网络传输（HTTP流水线）（默认不开启，浏览器基本都没有支持）



#### HTTP/1.1缺点

明文传输、不校验身份、不检验完整性

不安全（有窃听 伪装 篡改的风险）



队头阻塞(包括客户端的和服务端的)纯文本协议，请求与响应没有序号标识，所以一个请求只能等到响应后才能发送下一个请求。

（服务端处理某个请求耗时比较长，后面的请求的处理都会被阻塞）

头部巨大（头部不压缩，每次互相发送相同的首部造成的浪费较多）

请求只能从客户端开始，服务端只能被动响应

#### 如何优化HTTP/1.1

避免发送HTTP请求

- 缓存

减少发送HTTP请求次数

- 合并请求（合并资源）
- 减少重定向次数
- 减少发送请求（当前不需要的资源没必要立刻发送请求）

减少HTTP响应数据

- 无损压缩
- 有损压缩

不管怎么优化都是有限的，所以才会出现HTTP/2 3

#### HTTP/2做了什么改进？

https://www.bilibili.com/video/BV1Jz4y1B7st/?spm_id_from=333.337.search-card.all.click&vd_source=b6f488ad5f35012603ce909e871e0ded

基于HTTPS，安全上有了保障

性能上：

- 头部压缩 

HTTP/2 使⽤ HPACK 压缩算法对请求和响应头部进⾏压缩，减少了传输的头部数据量，降低了延迟。

- 二进制格式

HTTP/2 将数据分割成⼆进制帧进⾏传输，分为**头信息帧和数据帧**，增加了数据传输的效率。

- 并发传输

引出了 Stream 概念，多个 Stream 复⽤在⼀条 TCP 连接，针对不同的 HTTP 请求⽤独⼀⽆⼆的

Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息

- 服务器主动推送资源

服务器可以对客户端的⼀个请求发送多个响应，即服务器可以额外的向客户端推送资源，⽽⽆需客户端明确的请求。





头部压缩：

静态字典：为⾼频出现在头部的字符串和字段建⽴了⼀张**静态表**，它是写⼊到 HTTP/2 框架⾥的，不会变化的

动态字典：客户端和服务器在传输报文的过程中动态更新编码表。

huffmman编码：是将⾼频出现的信息⽤「较短」的编码表示，从⽽缩减字符串⻓度。



二进制帧：

HTTP/2 引入了帧的概念，将纯文本协议转换成二进制协议。帧是数据传输的最小单位。把请求和响应分成了头信息帧和数据帧，并且采用二进制编码。



什么是流？由什么组成

并发传输：流（Stream）是逻辑上的概念，一个资源请求和对应的响应就是一个流，一个流由多个帧组成，用同一个流id表示。接收方可以通过流id将帧关联起来，从而实现乱序请求和相应的关联。

HTTP/2 允许在一个 TCP 连接上同时传输多个流，并且不同流的帧可以乱序发送，实现了并发传输解决了 HTTP/1.1 的队头阻塞问题。

- 不同流的帧可以乱序发送，但同一流内的帧必须保持严格顺序。接收端通过帧头中的 Stream ID 识别帧的归属，并将它们重新组装成完整的 HTTP 消息
- HTTP/2 允许客户端为流设置优先级，这样可以优化关键资源的加载顺序，进一步提升性能



举例：传输三个文件，发送端会把每个文件切割成多个数据帧并且编号，不同的文件标记不同的流id，三个文件可以乱序发送，接收方根据流id重新组装还原数据。

![image-20250418123000286](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250418123000286.png)



服务器推送：

1.1服务器只能被动的响应，2.0可以主动向客⼾端发送消息

客户端在访问 HTML 时，服务器可以直接主动推送 CSS ⽂件，减少了消息传递的次数。





![image-20250224215025213](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250224215025213.png)



#### HTTP3







#### HTTP2 和3的区别











#### HTTP/HTTPS区别

安全：HTTP是明⽂传输，HTTPS在TCP和HTTP中间加⼊了SSL/TLS安全协议，加密传输

握⼿次数：HTTP三次握⼿即可，HTTPS在三次握⼿后还需要SSL/TLS的三次握⼿过程

端⼝：HTTP端⼝号为80，HTTPS端⼝号为443

证书：HTTP不需要，HTTPS协议需要向CA申请数字证书

#### HTTPS做了什么

混合加密（防窃听）

摘要算法（防篡改）

CA证书（防冒充）

#### 对称加密 非对称加密

⾮对称加密：

**加密和解密使⽤不同的秘钥，⼀把作为公开的公钥，另⼀把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。**

优点：**安全性更⾼**，公钥是公开的，秘钥是⾃⼰保存的，不需要将私钥给别⼈。

缺点：**加密和解密花费时间⻓、速度慢，只适合对少量数据进⾏加密。**



对称加密：

**加密和解密使⽤同⼀个秘钥**

优点：算法公开、计算量⼩、**加密速度快、加密效率⾼**。

缺点：**不够安全，如何安全的将秘钥传输给另一方是一方面，另一方面如果⼀⽅的秘钥被泄露，那么加密信息也就不安全了。**

另外，每对⽤⼾每次使⽤对称加密算法时，都需要使⽤其他⼈不知道的唯⼀秘钥，这会使得收、发双⽅所拥有的钥匙数量巨⼤，密钥管理成为双⽅的负担。



#### SSL/TLS  RSA握手

- 第⼀次（Client Hello）：客⼾端向服务端发起连接请求，客⼾端发第⼀个随机数，发⾃⼰⽀持的加密规则

- 服务端发第二个随机数，选加密算法。服务端发证书（证书⾥有公钥）给客⼾端
- 客户端验证证书。并生成第三个随机数，通过公钥加密，发送给客户端。生成会话秘钥，发送切换加密模式的消息。
- 服务端用私钥解密得到第三个随机数，生成会话秘钥。发送切换加密模式的消息以及握手完成的消息。



#### SSL/TLS  ECDHE握手

- 第⼀次（Client Hello）：客⼾端向服务端发起连接请求，客⼾端发第⼀个随机数，发⾃⼰⽀持的加密规则
- 服务端发第二个随机数，选加密算法。服务端发证书（证书⾥有公钥）给客⼾端。生成自己的椭圆曲线公钥私钥，把公钥发送给客户端。
- 客户端验证证书。生成客户端的椭圆曲线公钥私钥，公钥发送给客户端。生成会话秘钥。发送切换加密模式的消息。
- 得到客户端公钥，生成会话秘钥。发送切换加密模式的消息以及握手完成的消息。



#### RSA加密算法缺点

不支持前向保密。一旦服务端私钥泄露，所有通信内容都能被解密。

#### RSA 和 ECDHE 握⼿过程的区别：

RSA 密钥协商算法「不⽀持」前向保密，ECDHE 密钥协商算法「⽀持」前向保密；

使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个消息

的往返时间





#### COOKIE   SESSION   

**Cookie** 是服务器发送给客户端浏览器的一小段数据，浏览器会将其保存在本地，并在之后的每次请求中自动携带该数据回传给服务器。

1. 客户端向服务端发起 HTTP 请求。
2. 服务端在响应头中通过 `Set-Cookie` 指令返回 Cookie 数据。
3. 浏览器接收到响应后，自动在本地保存 Cookie。
4. **之后每次请求同一域名资源时，浏览器会自动携带该 Cookie 发给服务器。**

📌 **用途：** 标识用户身份、保存用户偏好或登录信息等。



**Session** 是服务器在用户访问期间为其创建的一个会话对象，用来存储用户在服务端的临时状态信息（如登录信息、购物车等）。

1. 客户端发起请求，服务端创建一个用于标识用户状态的 `Session` 对象，并生成唯一 `session_id`。
2. 服务端通过 `Set-Cookie` 把 `session_id` 返回给客户端，浏览器保存它为 Cookie（如：`Cookie: sessionid=abc123`）。
3. 客户端之后的请求中自动携带这个 `session_id`，服务端根据它查找到对应的 Session 对象，维持用户状态。

📌 **用途：** 保存用户的登录信息、购物车内容等敏感或临时状态。

[还分不清 Cookie、Session、Token、JWT？ - 知乎](https://zhuanlan.zhihu.com/p/164696755)



#### 分布式SESSION的问题

[分布式session的几种解决方案，你中意哪种？ - 知乎](https://zhuanlan.zhihu.com/p/370644206)



#### websocket和http区别

相同：WebSocket和HTTP都是应⽤层协议，都是可靠传输协议，都基于TCP

不同：

HTTP 是单向、短连接的请求-响应协议，服务端不能主动推送消息；WebSocket 是双向、持久连接协议，支持服务器主动推送消息。

使用场景

http  网页加载、表单提交、API 请求等

websocket  聊天、推送、在线游戏、股票行情等

#### 数字签名  数字证书

#### https://zhuanlan.zhihu.com/p/43789231











### DNS

#### 什么是DNS

主要作用是将人类易于理解的域名（如`www.example.com`）转换为计算机能够识别的IP地址（如`93.184.216.34`）。这种转换过程被称为**域名解析**。



#### DNS域名解析过程

- 先在浏览器中查找域名对应的IP地址缓存，再找硬盘中的hosts⽂件如果浏览器缓存和hosts⽂件中都没有ip地址，浏览器会发⼀个DNS请求给本地dns服务器（⽹络接⼊服务商提供）。
- 本地DNS服务器先查询缓存记录，有记录直接返回结果。缓存中没有还要向DNS根服务器进⾏查询，根域名服务器返回顶级域名服务器地址
- 本地DNS服务器向顶级域名服务器（com）发出请求，顶级域名服务器返回权威域名服务器的ip
- 本地服务器向权威服务器（server.com）发出请求，得到域名和IP地址的对应关系
- 本地域名服务器将ip地址返回给客户端

![image-20250225125254775](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250225125254775.png)

#### 递归查询 迭代查询

- **客户端与本地DNS服务器之间**：客户端使用递归查询，将查询过程完全交给本地DNS服务器。
- **本地DNS服务器与其他DNS服务器之间**：本地DNS服务器可能会使用迭代查询，逐级向其他DNS服务器请求解析结果。



#### DNS使用的协议

##### 域名解析使用UDP

- **背景**：域名解析是客户端向DNS服务器查询域名对应的IP地址的过程。
- **原因**：
  1. **速度**：UDP协议速度快，适合快速响应的DNS查询。
  2. **开销小**：UDP协议不需要建立连接，适合简单的查询和响应。
  3. **数据量小**：大多数DNS查询和响应的数据量较小（通常不超过512字节），UDP足以满足需求。

##### 区域传送使用TCP

- **背景**：DNS区域传输是指主DNS服务器将区域文件同步到辅助DNS服务器的过程。
- **原因**：区域文件**通常较大**，且同步过程**需要保证数据的完整性和可靠性**。

#### DNS负载均衡

通过DNS解析将一个域名解析为多个IP地址，从而将流量分配到不同的服务器。

- 在DNS服务器中，针对一个域名可以配置多个A记录（即IPv4地址），每个A记录对应一个服务器的IP地址。

- DNS服务器根据预设的负载均衡算法（如轮询、加权轮询、地理位置感知等）选择一个合适的IP地址返回给用户。



#### DNS域名缓存

**DNS 域名缓存（DNS Cache）\**是指：在解析域名（如 `www.example.com`）时，系统或浏览器会\**临时保存域名与 IP 地址的对应关系**，以便下次访问相同域名时**无需再次向 DNS 服务器查询**，从而加快访问速度、减少网络开销。



**浏览器缓存**
 浏览器会先检查是否已缓存了域名的解析结果。

**操作系统缓存**
 如 Windows 的 `DNS Client` 服务或 Linux 的 `nscd`/`systemd-resolved`，也会缓存 DNS 结果。

**本地网络设备**
 路由器或本地 DNS 服务器也可能有缓存。

**ISP 的 DNS 服务器**
 你的网络运营商的 DNS 服务器通常会缓存大量常用域名。



### TCP/UDP

#### 什么是TCP

TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议。

**⾯向连接**：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，

也就是⼀对多是⽆法做到的；

**可靠的**：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；

**字节流**：⽤户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报⽂，如果

接收⽅的程序如果不知道「消息的边界」，是⽆法读出⼀个有效的⽤户消息的。并且 TCP 报⽂是

「有序的」，当「前⼀个」TCP 报⽂没有收到的时候，即使它先收到了后⾯的 TCP 报⽂，那么也不

能扔给应⽤层去处理，同时对「重复」的 TCP 报⽂会⾃动丢弃。





#### TCP   UDP特点

TCP：⾯向连接、可靠的，基于字节流，点对点、全双⼯（两⽅在任何时候都能发送数据），首部开销大

UDP：⽆连接、不可靠，基于数据报，不仅⼀对⼀、⾸部开销⼩

#### TCP   UDP对应的场景  协议

TCP：

**特点**：面向连接、可靠传输、数据有序、流量控制与拥塞控制

**典型应用场景**：对数据完整性要求高的场合

**常见协议**：

- HTTP / HTTPS（网页传输）
- FTP（文件传输）
- SMTP / POP3（邮件传输）
- TELNET / SSH（远程登录）

UDP：

**特点**：面向无连接、传输不可靠、速度快、资源开销小

**典型应用场景**：实时性要求高、可容忍丢包的场合

**常见协议**：

- DNS（域名解析）
- TFTP（简易文件传输协议）
- 音视频通话、直播、在线游戏（低延迟要求）
- 局域网广播、多播通信



#### TCP UDP区别

![image-20250225155127948](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250225155127948.png)



#### TCP首部字段

```
0      4      8      12     16     20     24     28     32bit
+------------------------------------------------------------+
|       源端口（16位）        |      目标端口（16位）        |
+------------------------------------------------------------+
|                      序列号（32位）                      |
+------------------------------------------------------------+
|                  确认号（32位）                          |
+------------------------------------------------------------+
| 数据偏移（4） | 保留（3）| 控制位（9位） |  窗口大小（16）    |
+------------------------------------------------------------+
|       校验和（16）         |    紧急指针（16）            |
+------------------------------------------------------------+
|             可选项（可变长） + 填充字段（使头部是4字节对齐）  |
+------------------------------------------------------------+

```



#### UDP头部字段

| 字段名称 | 长度（字节） | 说明                           |
| :------- | :----------- | :----------------------------- |
| 源端口   | 2            | 发送方端口号（可选）           |
| 目的端口 | 2            | 接收方端口号                   |
| 长度     | 2            | UDP数据报的总长度（首部+数据） |
| 校验和   | 2            | 用于检测错误的校验和           |



#### 三次握手

![image-20250225160626797](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250225160626797.png)

一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态

客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。

服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。

客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。

服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。



从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**







#### ISN是怎样随机生成的

ISN = M + F(localhost, localport, remotehost,remoteport)。

M 是⼀个计时器，这个计时器每隔 4 微秒加 1。

F 是⼀个 Hash 算法，根据源 IP、⽬的 IP、源端⼝、⽬的端⼝⽣成⼀个随机数值。要保证 Hash 算法不能被外部轻易推算得出，⽤ MD5 算法是⼀个⽐较好的选择。

可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成⼀样的初始化序列号。



#### 为什么是三次握手，不是两次 四次

- 阻止重复历史连接的初始化

客户端连续发送多次 SYN（都是同⼀个四元组）建⽴连接的报⽂，在**⽹络拥堵**情况下：

⼀个「旧 SYN 报⽂」⽐「最新的 SYN」 报⽂早到达了服务端，那么此时服务端就会回⼀个 SYN +ACK 报⽂给客户端，此报⽂中的确认号是 91（90+1）。

客户端收到后，发现⾃⼰期望收到的确认号应该是 100 + 1，⽽不是 90 + 1，于是就会回 RST 报⽂。

服务端收到 RST 报⽂后，就会释放连接。

后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握⼿了。



**在两次握⼿的情况下，服务端没有中间状态给客户端来阻⽌历史连接，导致服务端可能建⽴⼀个历史连接，造成资源浪费**。

在两次握⼿的情况下，服务端在收到 SYN 报⽂后，就进⼊ ESTABLISHED 状态，意味着这时可以

给对⽅发送数据，客户端判断到此次连接为历史连接，那么就会回 RST 报⽂来断开连接，⽽服务端在第⼀次握⼿的时候就进⼊

ESTABLISHED 状态，所以它可以发送数据的造成资源浪费，它只有在收到 RST 报⽂后，才会断开连接。



- 同步双方初始序列号

当客户端发送携带「初始序列号」的 SYN 报⽂的时候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步。**

⽽两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。

- 避免不必要的资源浪费

如果客户端发送的 SYN 报⽂在⽹络中阻塞了，重复发送多次 SYN 报⽂，那么服务端在收到请求后就

会**建⽴多个冗余的⽆效链接，造成不必要的资源浪费。**





「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；

「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。

#### 为什么ISN要随机产生

**如果每次建⽴连接，客户端和服务端的初始化序列号都是⼀样的话，快速重连一个TCP连接的情况下，很可能会出现旧的连接被网络阻塞的数据包的序列号刚好在新连接的接受窗口的情况**。

防止攻击者预测序列号，增强安全性



#### 第⼀⼆三次丢包各会发⽣什么？

第⼀次：客⼾端发送的SYN丢失；客⼾端没有收到服务器的SYN/ACK包；客⼾端超时重传n次SYN包之后不再发送，断开连接（RTO时间指数上涨）（tcp_syn_retries）。

第⼆次：服务器的SYN/ACK包丢失；服务器没有收到客⼾端ACK包，客⼾端也没有收到服务器的SYN/ACK包；客⼾端客⼾端超时重传n次SYN包之后不再发送，服务器超时重传n次SYN/ACK包后不再发送，断开连接（tcp_synack_retries）

第三次：客⼾端发送的ACK丢失；服务器没有收到客⼾端ACK包；服务器超时重传n次SYN/ACK包后不再发送断开连接；





#### 四次挥手

![三分恶面渣逆袭：TCP 四次挥手](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ba156295-03af-46dc-8ef3-869b44b11303.jpg)

客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。

服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSE_WAIT 状态。

客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。

等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。

客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态

服务端收到了 ACK 应答报⽂后，就进⼊了 CLOSE 状态，⾄此服务端已经完成连接的关闭。

客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSE 状态，⾄此客户端也完成连接的关闭。



 

#### 为什么需要四次

客⼾端发送FIN仅表⽰客⼾端不发送了但是还可以接收

服务端收到FIN后回⼀个ACK，但是服务端可能还有数据需要处理和发送，等服务端不再发送数据才发送FIN





#### 四次挥手可以变成三次吗

当被动关闭方在 TCP 挥⼿过程中，「**没有数据要发送」并且「开启了** **TCP** **延迟确认机**

**制」，那么第⼆和第三次挥⼿就会合并传输，这样就出现了三次挥⼿。**



TCP延迟确认机制：

发送没有携带数据的 ACK，⽹络效率很低，因为也有 40 个字节的 IP 头 和 TCP 头，但却

没有携带数据报⽂。

为了解决 ACK 传输效率低问题，所以就衍⽣出了 **TCP 延迟确认**。

TCP 延迟确认的策略：

当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅

当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送

如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK





#### 四次挥手丢失会发生什么

- 第一次丢失客户端迟迟收不到被动⽅的 ACK 的话，也就会触发超时重传机制，重传 FIN报⽂。

- 当客户端重传 FIN 报⽂的次数达到一定次数后，就不再发送 FIN 报⽂，则会在等待⼀段时间

  （时间为上⼀次超时时间的 2 倍），如果还是没能收到第⼆次挥⼿，那么直接进⼊到 close 状态。
  
  

- 第二次丢失，ACK 报⽂是不会重传的，所以如果服务端的第⼆次挥⼿丢失了，客户端就会触发超时

  重传机制，重传 FIN 报⽂，直到收到服务端的第⼆次挥⼿，或者达到最⼤的重传次数。



- 第三次丢失，服务端会收不到 ACK，服务端就会重发 FIN 报⽂，直到达到最大次数，或者收到ACK。

- 客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时⻓限制的，如果限制时间内还是没能收到服务端的第三次挥⼿（FIN 报⽂），那么客户端就会断开连接。

  

- 如果第四次挥⼿的 ACK 报⽂没有到达服务端，服务端就会重发 FIN 报⽂，直到到达重发次数或者收到ACK报文。

#### TIME_WAIT为什么2MSL？/为什么要等待2MSL?

MSL：TCP报文段在网络中的最大生存时间，通常为30s到2min

- 保证ACK能被被动连接⽅收到（客户端发送ACK后，如果被动⽅没有收到ACK，被动⽅则会重发FIN，这样一来一回正好两个MSL的时间。每收到⼀次服务端的FIN就重启计时器）

- 使得旧连接的数据包得以消失，防⽌出现在之后的连接中。（这个时间**⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。**）

#### TCP和UDP可以同时绑定相同的端口吗

可以。

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

#### 多个 TCP 服务进程可以绑定同一个端口吗？

- 如果两个 TCP 服务进程绑定的 IP 地址不同，而端口相同的话，也是可以绑定成功的
- 如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。



#### 重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？

- 当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。

- **SO_REUSEADDR** 作用是：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功。



#### 客户端的端口可以重复使用吗

TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为**内核是通过四元组信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。**



#### 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？

要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。
如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。



#### 如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？

打开 net.ipv4.tcp_tw_reuse 这个内核参数。
因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。
如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

#### 什么场景下服务端会主动断开TCP连接

- 没有开启HTTP长连接
- HTTP长连接超时
- HTTP长连接的请求数量达到上限







#### TIME_WAIT太多怎么办（优化TIME_WAIT）

**客户端端口资源耗尽**：一个主机最多只能有约 65536 个端口，过多的 `TIME_WAIT` 占用会导致**无法建立新的 TCP 连接**。

**服务端资源占用**：服务端维护大量 `TIME_WAIT` 连接会占用内存、连接句柄、线程池等资源，**影响新连接的接入和处理**。

- 修改内核参数：端⼝复⽤（net.ipv4.tcp_tw_reuse 允许重用处于 `TIME_WAIT` 状态超过 1 秒的端口。）；

- #### 使用长连接（Keep-Alive）：

  - 避免频繁建立和关闭连接，**大幅减少 `TIME_WAIT` 产生**。

- 使用SO_LINGET强制断开连接。（发送RST包给对端跳过四次挥⼿，直接进⼊CLOSE状态）

- **如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客⼾端去断开，由分布在各处的客⼾端去承受 TIME_WAIT。**





#### 如果已经建立了连接，但是客户端出现故障，会发生什么（TCP保活机制）

定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀个

时间间隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，**如果连续⼏个探测报⽂都没有得到响应，**

**则认为当前的 TCP 连接已经死亡**，系统内核将错误信息通知给上层应⽤程序。



- 需要的时间很长，可以在应用层实现类似的机制

- web 服务软件⼀般都会提供 keepalive_timeout 参数，⽤来指定 HTTP ⻓连接的超时时间。如果

  设置了 HTTP ⻓连接的超时时间是 60 秒，web 服务软件就会**启动⼀个定时器**，如果客户端在完成⼀个

  HTTP 请求后，在 60 秒内都没有再发起新的请求，**定时器的时间⼀到，就会触发回调函数来释放该连接。**



#### **如果已经建⽴了连接，但是服务端的进程崩溃会发⽣什么？**

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，**内核需要回收该进程的所有 TCP 连接资**

**源**，于是内核会发送第⼀次挥⼿ FIN 报⽂，后续的挥⼿过程也都是在内核完成，并不需要进程的参与，所

以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥⼿的过程。



#### TCP连接，一端断电和进程崩溃有什么区别









#### **TCP Keepalive** **和** **HTTP Keep-Alive** **是⼀个东⻄吗？**

HTTP 的 Keep-Alive，是由**应⽤层（⽤户态）** 实现的，称为 HTTP ⻓连接；

TCP 的 Keepalive，是由 **TCP** **层（内核态）** 实现的，称为 TCP 保活机制；



HTTP 的 Keep-Alive 也叫 HTTP ⻓连接，该功能是由「应⽤程序」实现的，**可以使得⽤同⼀个 TCP 连接来发送和接收多个 HTTP 请求/应答**，减少了 HTTP 短连接带来的多次 TCP 连接建⽴和释放的开销。



如果两端的 TCP 连接⼀直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核⾥的 TCP 协议栈就会发送探测报⽂。

如果对端程序是正常⼯作的。当 TCP 保活的探测报⽂发送给对端, 对端会正常响应，这样 **TCP** **保活时间会被重置**，等待下⼀个 TCP 保活时间的到来。

如果对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 *FIN* 报⽂，⽽主机宕机则是⽆法感知的，所以需要 *TCP* 保活机制来探测对⽅是不是发⽣了主机宕机），或对端由于其他原因导致报⽂不可达。当 TCP 保活的探测报⽂发送给对端后，没有响应，连续⼏次，达到保活探测次数后，**TCP** **会报告该** **TCP** **连接已经死亡**。







#### TCP如何保证的可靠性？

序列号/确认应答：根据序列号对数据进⾏排序，还可以去掉重复的数据；根据序列号可以知道收到了哪些数据，下次从哪⾥发送

校验和/数据包校验：检验接受的数据是否有异常和差错，如果出现差错，则丢弃TCP段，重发

超时重传：

流量控制：B通过告诉A缓冲区的⼤⼩，控制A的发送量

拥塞控制：通过慢启动、拥塞避免、快速重传、快速恢复避免⽹络阻塞



滑动窗⼝：解决了必须⼀发⼀答才能再发的问题提⾼了报⽂传输的效率





#### 重传机制

- 超时重传：重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的ACK 确认应答报⽂，就会重发该数据，也就是我们常说的**超时重传**。

  TCP 会在以下两种情况发⽣超时重传：数据包丢失、确认应答丢失

- 快速重传：收到三个冗余ACK

- SACK：快速重传的时候，是重传一个，还是重传所有的？

  在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它**可以将已收到的数据的信息发送给「发送⽅」，这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据**。

- D-SACK 使用SACK来告诉发送方，那些数据被重复接受了。

1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了;

2. 可以知道是不是「发送⽅」的数据包被⽹络延迟了;

3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了;



#### 为什么快速重传选择3次ACK

冗余ACK有可能是乱序，有可是丢失



#### 滑动窗口



原因：TCP每次发送⼀个数据(MSS)都要进⾏⼀次应答(ACK)，只有上⼀个收到确认才发送下⼀个，效率低

窗⼝：操作铣系统辟的缓冲空间，窗口大小表示⽆需等待确认应答，⽽可以继续发送数据的最⼤值

WINDOW字段：**接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。**就达到了流量控制的目的。



发送方的滑动窗口：已发送并确认 <- 已发送未确认 <- ⽴即要发送的 <- 还没有进⼊窗⼝的（窗⼝ = 已发送未确

认 + ⽴即要发送的）

![image-20250228172447274](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250228172447274.png)



接收方的滑动窗口：已接收并确认<-未收到收据但可以接收<-未收到收据但不能接收

![image-20250228172754077](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250228172754077.png)



#### 流量控制

原因：发送⽅⼀直发送，接收⽅处理不过来，发送⽅会重发，影响性能，所以提出了流量控制

流量控制：每次接收到数据后会将剩余可处理数据的⼤⼩告诉发送⽅，控制发送速率，保证来得及接受



问题1（⼩林）：没有被处理的数据存放在缓冲区，操作系统管理，系统繁忙会导致缓冲区减⼩，会导致丢包，怎么办？

解决1：所以TCP不允许同时减少缓存⼜收缩窗⼝（先收缩窗⼝，过段时间在减少缓存，避免了丢包）



问题2（⼩林）：接收⽅窗⼝⼤⼩为0之后告诉发送⽅，之后窗⼝⼤⼩变⼤的报⽂丢失了，发送⽅⼀直认为0，进⼊死锁，怎么办？

解决2：零窗⼝通知之后启动持续计时器，超时就会主动发送窗⼝探测报⽂。对方在确认探测报文时，给出自己窗口的大小。



问题3（⼩林）：糊涂窗⼝综合症，接收窗⼝已经很⼩了，但是发送⽅还是义⽆反顾的发送，TCPIP头部本来就⼤，只传输了⼏个字节，影响性能

解决3：接收⽅避免通告⼩窗⼝（窗口小到一定程度后，通告窗口为0），发送⽅避免发送⼩数据（Nagle算法）（条件⼀：要等到窗⼝⼤⼩ >= MSS 并且 数据⼤⼩ >= MSS ；

条件⼆：收到之前发送数据的 ack 回包；两个条件都满足，才会发数据）



#### 拥塞控制

原因：⽹络出现拥堵时，继续发送数据会导致丢失，再重传，反⽽再次增⼤了⽹络负担，死循环

拥塞控制：避免发送⽅的数据填满整个⽹络



怎么知道当前⽹络是否出现了拥塞呢？

只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是**发⽣了超时重传，就会认为⽹络出现了拥塞。**



慢启动：每收到⼀个ACK，cwnd += 1（发1、ACK1、+1，第⼆次发2、ACK2、+2，**指数增⻓**）

拥塞避免：cwnd = ssthresh时候，每收到⼀个ACK，cwnd += 1/cwnd（发8，ACK8，+1/8 * 8，**线性增⻓**）

超时重传的拥塞发生算法：ssthresh 设为 cwnd/2 ，cwnd 重置为初始值

快速重传的拥塞发生算法：cwnd = cwnd/2 ，也就是设置为原来的⼀半;ssthresh = cwnd ;进⼊快速恢复算法。（这种情况不严重，因为大部分没丢，只丢了一小部分）



快速恢复算法：

拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；

重传丢失的数据包；

如果再收到重复的 ACK，那么 cwnd 增加 1；

如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的

数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态

了，也即再次进⼊拥塞避免状态；

![image-20250228195130531](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250228195130531.png)

#### BBR算法：

**BBR（Bottleneck Bandwidth and RTT）算法**是一种TCP拥塞控制算法，它通过**估算网络的瓶颈带宽和往返时延（RTT）来调节发送速率**，从而提高网络利用率，减少拥塞和延迟。与传统的基于丢包信号的拥塞控制算法（如TCP Reno、CUBIC）不同，BBR通过实时监控带宽和延迟来进行调优，而不是单纯依赖丢包来调整窗口大小。

- **高带宽利用率**：BBR能更有效地利用网络带宽，避免传统算法中的缓慢拥塞恢复。
- **低延迟**：通过监控RTT并根据网络状态调整发送速率，BBR能够避免因过度发送导致的拥塞，从而降低延迟。
- **抗丢包能力**：BBR减少了对丢包的依赖，降低了因丢包带来的性能损失。

**对某些网络环境可能不稳定**：在一些高丢包率或非常复杂的网络环境下，BBR可能表现不如传统的基于丢包的算法。



#### 半连接队列 全连接队列

被动⽅收到SYN请求后放⼊半连接队列（SYN队列）

被动⽅收到ACK报⽂后放⼊全连接队列（accept队列）

个队列都有⼤⼩限制，超过容量就丢弃连接或者返回RST包

![image-20250228180529141](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250228180529141.png)





#### 如何理解TCP是面向字节流的协议？粘包，拆包，如何解决？

- UDP协议，操作系统不对消息进行拆分，每个UDP报文就是一个完整的用户消息。没有粘包拆包。有丢包乱序。
- TCP协议，消息可能会被操作系统分成多个TCP报文。TCP把应⽤层传来的⼤⼩不等的数据块仅看成⼀连串⽆结构的字节流，没有边界；TCP⾸部也没有表⽰数据⻓度的字段

- 粘包：两个消息的某部分被分到了同一个TCP报文。（发送端的多个短的消息在发送缓冲区堆积，接收端处理数据的速度慢）

- 拆包：发送端的⼀个数据包⼤于TCP缓冲区⼤⼩；⼤于MSS⼤⼩；⼤于MTU⼤⼩。（打的数据包被拆分成小的TCP报文进行传输）

解决粘包：固定长度消息。特殊字符作为边界。自定义消息结构体。



#### ⼀些名词：MTU、MSS、RTO、RTT？

Maximum Transmit Unit，最⼤传输单元：IP头部 + TCP头部 + 数据。一个网络包的最大长度，一般为1500字节。

Maximum Segment Size，最⼤报⽂段⻓度：数据

Retransmission Time Out，重传超时时间

Round Trip Time，连接的往返时间



#### 既然IP层会分片，TCP为什么还要有MSS

TCP不分片，IP就要分片。在接收端，所有分片必须成功到达才能重新组装为一个完整的包。丢失一个分片就会导致整个包重传，增加了重传延迟和带宽消耗。

数据在TCP分段，就是为了在IP层不需要分⽚，同时发⽣重传的时候只重传分段后的⼩份数据



#### 为什么会有MSS，没有MSS怎么办？

⼒求在TCP分⽚，如果在IP分⽚的话，只有第⼀个包⾥有TCP头部，如果丢失其中⼀个，需 要重传整个TCP数据



#### TCP连接失败的原因

防⽕墙隔离

⽹络故障，可以通过ping进⾏调试

client分配不到端⼝

server端连接队列已满





### IP

#### ip地址的分类

A：开头0，⽹络号8位

B：开头10，⽹络号16位

C：开头110，⽹络号24位

D：开头1110，⽤作多播

E：开头1111，保留

![image-20250303114306503](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303114306503.png)

![image-20250303114420192](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303114420192.png)



IP分类的优点：简单明了，选路（基于IP地址）简单

IP分类缺点：同一网络下没有地址层次（同意公司内无法划分地址层次）

不能很好与现实进行匹配（C类地址包含的主机数量太少，A类地址包含的主机数量太多，浪费地址）

#### 单播、多播、⼴播？

单播：⼀对⼀通讯

⼴播：同⼀⽹络中的主机

多播：跨越不同⽹络，传送给属于多播组的多个主机



#### 无分类编址CIDR

不再有分类地址的概念，32 ⽐特的 IP 地址被划分为两部分，前⾯是**⽹络号**，后⾯是**主机号**。

表示形式 a.b.c.d/x ，其中 /x 表示前 x 位属于**⽹络号**， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。



**⼦⽹划分实际上是将主机地址分为两个部分：⼦⽹⽹络地址和⼦⽹主机地址**。形式如下：

![image-20250303120104731](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303120104731.png)

#### IP地址与路由控制

IP地址的**⽹络地址**这⼀部分是⽤于进⾏路由控制。

路由控制表中记录着⽹络地址与下⼀步应该发送⾄路由器的地址。在主机和路由器上都会有各⾃的路由器控制表。

在发送 IP 包时，⾸先要确定 IP 包⾸部中的⽬标地址，再从路由控制表中找到与该地址具有**相同⽹络地址**

的记录，根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同⽹络地址的记录，就选择相同位数最多的⽹络地址，也就是最⻓匹配。

#### 环回地址

环回地址是在同⼀台计算机上的程序之间进⾏⽹络通信时所使⽤的⼀个默认地址。

计算机使⽤⼀个特殊的 IP 地址 **127.0.0.1** **作为环回地址**。与该地址具有相同意义的是⼀个叫做 localhost的主机名。使⽤这个 IP 或主机名时，数据包不会流向⽹络。

#### IP分片与重组

以太⽹的 MTU 是1500 字节。

当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被分⽚。

经过分⽚之后的 IP 数据报在被᯿组的时候，只能由⽬标主机进⾏，路由器是不会进⾏᯿组的。

假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数据报进⾏传输，再交由接收⽅重组成⼤数据报。



在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，所以 TCP 引⼊了 MSS 也就是在TCP 层进⾏分⽚不由 IP 层分⽚，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。



#### IPV4首部结构

![image-20250303122209478](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303122209478.png)



#### IPV6地址标识：

IPv4 地址⻓度共 32 位，是以每 8 位作为⼀组，并⽤点分⼗进制的表示⽅式。

IPv6 地址⻓度是 128 位，是以每 16 位作为⼀组，每组⽤冒号 「:」 隔开。

![image-20250303122645836](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303122645836.png)



#### IPV6头部和IPV4的区别：

**取消了⾸部校验和字段。** 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。

**取消了分⽚重新组装相关字段**。 分⽚与᯿组是耗时的过程，IPv6 不允许在中间路由器进⾏分⽚与᯿

组，这种操作只能在源与⽬标主机，这将⼤⼤提⾼了路由器转发的速度。

**取消选项字段。** 选项字段不再是标准 IP ⾸部的⼀部分了，但它并没有消失，⽽是可能出现在 IPv6 ⾸

部中的「下⼀个⾸部」指出的位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字节。

#### IPV6亮点

IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址，真是**便捷到即插即⽤**啊。

IPv6 包头包⾸部⻓度采⽤固定的值 40 字节，去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤**提⾼了传输的性能**。IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤**提升了安全性**。



















#### ARP协议

已知IP地址请求MAC地址

主机会通过**⼴播发送** **ARP** **请求**，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。

当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ **ARP** **响应包**返回给主机。

操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。

#### RARP协议

**已知** **MAC** **地址请求** **IP** **地址**。

通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络，接着：

该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。

RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。

#### DHCP



#### NAT



#### ICMP

**互联⽹控制报⽂协议**。

ICMP 主要的功能包括：**确认** **IP** **包是否成功送达⽬标地址、报告发送过程中** IP 包被废弃的原因和改善⽹络设置等。

在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将**由** **ICMP** 负责通知。

![image-20250303153051084](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250303153051084.png)



#### PING

测试在两台主机之间能否建⽴连接，向⽬的主机发送多个**ICMP回送请求报⽂**，没有响应则⽆法建⽴链接，有响应可以根据⽬的主机返回的回送报⽂的时间和响应的次数估算出数据包往返时间及丢包率。

#### PING的作用





#### traceroute

作⽤⼀：获取路径上的路由器的IP地址；按从1开始的顺序递增TTL发送请求，每次都在⼀个路由器失效，返回路由器IP和ICMP差错报文（时间超时），所有过程加起来可以获得路径上所有路由器的IP

作用二：**故意设置不分片，从而确定链路的MTU**

⾸先在发送端主机发送 IP 数据报时，将 IP 包⾸部的**分⽚禁⽌标志位设置为** **1**。根据这个标志位，途中的路由器不会对⼤数据包进⾏分⽚，⽽是将包丢弃。

随后，通过⼀个 ICMP 的不可达消息将**数据链路上** **MTU** **的值**⼀起给发送主机，不可达消息的类型为「**需要进⾏分⽚但设置了不分⽚位**」。

发送主机端每次收到 ICMP 差错报⽂时就**减少**包的⼤⼩，以此来定位⼀个合适的 MTU 值，以便能到达⽬标主机。



#### 为什么要有IP地址，为什么要有MAC地址





#### 127.0.0.0	0.0.0.0	localhost	本机地址

127.0.0.1 是**回环地址**。 localhost 是**域名**，但默认等于 127.0.0.1 。

ping 回环地址和 ping 本机地址，是⼀样的，⾛的是**lo0 假⽹卡**，都会经过⽹络层和数据链路层等逻辑，最后在快要出⽹卡前**狠狠拐了个弯**， 将数据插⼊到⼀个**链表**后就**软中断**通知 **ksoftirqd** 来进⾏**收数据**的逻辑，**压根就不出⽹络**。所以断⽹了也能 ping 通回环地址。

如果服务器 listen 的是 0.0.0.0 ，那么此时⽤ 127.0.0.1 和本机地址**都可以**访问到服务。



### 安全性问题

#### 说说有哪些安全攻击

- **被动攻击**：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。
- **主动攻击**：直接对现有的数据和服务造成影响，常见的主动攻击类型有：
- **篡改**：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。
- **恶意程序**：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。
- **拒绝服务 Dos**：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。



#### dos  ddos  drdos攻击

| 类型  | 全称                          | 特点                                                         |
| ----- | ----------------------------- | ------------------------------------------------------------ |
| DoS   | Denial of Service             | 单个攻击源反复发请求，占满服务器资源，使其无法处理正常请求。 |
| DDoS  | Distributed Denial of Service | 分布式攻击，多个攻击源（如被控制的僵尸机）同时发起请求，放大攻击效果。 |
| DRDoS | Distributed Reflection DoS    | 利用第三方服务器进行“反射”攻击，例如伪造目标 IP 请求公共 DNS 服务，从而让大量响应流向受害者。 |

针对 DDoS 中的流量攻击，最直接的方法是增加带宽

在带宽充足的前提下，还要提升核心网络设备（如路由器、交换机、网卡）的性能。

**使用抗 DDoS 防火墙或网关**（如 SYN Cookies 技术来防止内存资源被吃光）。

使用内核参数调优，限制半连接数量、连接超时时间。



#### 什么是SYN攻击，如何防御？

攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每

接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到

未知 IP 主机的 ACK 应答，久⽽久之就会**占满服务端的半连接队列**，使得服务端不能为正常⽤户服务。



防御：

增大半连接队列大小

使用SYNcookie技术

减少SYN+ACK重传次数





#### DNS劫持

DNS 劫持即域名劫持，**是通过将原域名对应的 IP 地址进行替换**，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。



**本地DNS劫持**

- 恶意软件修改了本机的`hosts`文件或DNS配置，把域名解析到攻击者指定的地址。

**运营商劫持**

- 某些运营商会拦截未解析成功的DNS请求，并重定向到自己的广告页面。

**DNS服务器劫持**

- 攻击者侵入DNS服务器，篡改域名解析记录。

**中间人攻击（MITM）**

- 攻击者在网络传输过程中篡改DNS请求或响应，返回伪造的解析结果。





应对：

- 直接通过 IP 地址访问网站，避开 DNS 劫持

- DNS劫持通常只能在特定的网络范围内进行，所以可以

  **使用可信的公共 DNS**：如

  - Google DNS：`8.8.8.8`
  - Cloudflare DNS：`1.1.1.1`



#### XSS攻击  如何避免

恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。



- 输入时过滤危险标签（如 `<script>`）
- 输出前做 HTML 编码，让恶意代码变成普通文字显示。
- 限制输入长度























### websocket

#### HTTP协议的局限性

- 无状态，不会保留客户端上下文。需要额外的机制，如cookie、session

- 性能问题：延迟（短连接）、浪费带宽（每次请求都要发送请求头，增加带宽消耗）
- 安全性：传统的HTTP是明文传输的，不安全
- 不支持双向通信，
- 请求重定向和缓存管理的复杂性。
- 适应性差（HTTP设计初衷是用于静态网页的传输）



#### websocket连接

WebSocket 默认使用以下两个端口：

80 端口：非加密的 WebSocket 协议，使用 ws:// 开头的 URL。
443 端口：加密的 WebSocket 协议（通过 TLS/SSL 加密），使用 wss:// 开头的 URL。




WebSocket 是基于 TCP 的协议。WebSocket 的连接**从一个标准的 HTTP 请求开始**，经过一次**协议升级**后，建立起一个全双工的 WebSocket 连接。

##### 握手阶段：

WebSocket 连接从 HTTP 请求开始，客户端通过 HTTP 升级机制请求升级协议：

- 客户端发起 HTTP 请求，并在请求头中包含特定的 WebSocket 字段以表示希望建立 WebSocket 连接。

  ```http
  GET /chat HTTP/1.1
  Host: example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Sec-WebSocket-Version: 13
  
  ```

  

- 服务器收到请求后，返回 101 状态码，并附带确认的握手信息。

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```









### RPC





















