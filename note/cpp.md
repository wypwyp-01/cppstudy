[TOC]





### C++基础
#### c 和 c++的区别：
+ c++引入了模板、异常处理、函数重载、运算符重载、命名空间、STL、引用等
+ c++面向对象，c 面向过程
+ c++引⼊new/delete的概念，取代了C中malloc/free的概念
+ C 更接近底层、语法简单 → 更适合底层开发
+ C++ 提供更多语法糖和工具 → 更适合复杂工程开发



#### c++与Java区别
+ Java 纯面向对象，运行在**虚拟机（JVM）**上，跨平台、开发效率高
+ 面向对象 + 过程式，运行在**本地机器**，偏向底层、高性能
+ Java没有指针的概念。自动分配和回收内存，c++需要手动管理。
+ Java适合Web应⽤，C++适合桌⾯程序。



#### cpp和Python区别
C++是编译语⾔，python是脚本语⾔

C++⽤花括号，python⽤缩进

| 语言 | 特点 |
| --- | --- |
| **C++** | 编译型、高性能、复杂但强大，适合系统级开发 |
| **Python** | 解释型、开发快、语法简单，适合脚本和数据处理 |


#### 从源⽂件到可执⾏⽂件？
预处理：

主要任务：处理#include、处理#define、条件编译#ifdef  #ifndef，去掉注释

输出：纯净的源代码文件

编译：

主要工作：将.i文件翻译成汇编文件

编译阶段进行语法分析、词法分析和语义分析，并且将代码优化后产生相应的汇编代码文件

输出：汇编文件（.s）

任何一个源文件在进行编译阶段的时候会去产生**符号表**，符号表中存放的就是程序所产生的符号（例如：函数名，变量名等），我们的编译阶段是不会去给符号分配正确的地址。**这些符号都没有被分配地址，因此.o文件没有经过链接是无法执行的。**



汇编：

将汇编代码转换为机器代码（二进制）



输出：目标文件.o



链接：

把多个目标文件（`.o`）合并

解析外部符号（如函数调用、变量引用）

给符号分配虚拟地址并和符号表中的符号一一对应起来（重定位）。

由链接器生成可执行文件

输出：可执行文件

![编译.drawio](C:\Users\wangyupeng\Downloads\编译.drawio.png)



#### 静态链接  动态链接
静态链接：

链接时把库代码复制到文件里，一起打包成可执行文件

优点：不⽤依赖库，可以独⽴执⾏

缺点：体积⼤；静态库更新需要重新链接



动态链接：程序运行时再加载外部库，不把库打包进可执行文件。编译时只记录“用到了哪个库”的符号引用程序运行时由操作系统去**加载共享库**

优点：节省空间：多个程序共享一个库文件

库更新时，程序**无需重新编译**即可受益（如修复 bug）

缺点：运⾏时加载，影响性能。运行时依赖系统的库版本。

### 基础语法
#### const关键字



#### volatile关键字
#### 指针相关：






#### 形参带默认值的函数
给默认值的时候从右向左给

调用效率的问题。（使用一个默认值，调用时就会少一个mov指令）

定义处可以给形参默认值，声明也可以给形参默认值

形参给默认值的时候，不管是定义处，还是声明处，形参默认值只能出现一次

##### 常量指针 指针常量
指针常量

**定义**：指针常量是一个指向固定地址的指针，其值（即它所指向的地址）不能被修改。

```c
int* const ptr;
```

+ `int*` 表示这是一个指向 `int` 类型的指针。
+ `const` 修饰的是指针本身，表示指针的值（地址）不能被修改。



常量指针是一个指向 `const` 类型数据的指针，它所指向的内容不能被修改。

```c
const int* ptr;
```

+ `const int` 表示指针所指向的内容是 `const` 类型。
+ `ptr` 是一个普通指针，可以指向不同的地址，但不能修改它所指向的内容。

##### 悬挂指针 野指针
都是指向无效的内存区域，访问将会导致未定义行为。

野指针：没有被初始化过的指针。     定义时初始化或置空。

悬挂指针：指针最初指向的内存已经被释放掉了。    使用cpp11智能指针   或    释放操作后立即置空。



##### 数组指针  指针数组
[https://c.biancheng.net/view/335.html](https://c.biancheng.net/view/335.html)

数组指针和指针数组是 C/C++ 中两种常见的指针类型，它们之间的区别在于定义方式和指向的内容不同。以下是它们的详细解释：

###### 1. 数组指针（Pointer to an Array）
数组指针是指向整个数组的指针。数组指针本质上是指向数组的首地址，并且它的类型包含了数组的大小。

```plain
type (*pointer)[size];
```

+ `pointer` 是一个指针，它指向一个包含 `size` 个元素的数组，每个元素的类型是 `type`。
+ `*pointer` 代表指向的数组，而 `pointer` 本身是指向数组的指针。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int (*ptr)[5] = &arr;  // ptr 是一个指向包含 5 个整数的数组的指针

printf("%d\n", (*ptr)[2]);  // 输出 3，因为 ptr 指向 arr 数组
```

+ 这里 `ptr` 是一个指针，指向一个包含 5 个整数的数组。
+ `(*ptr)[2]` 通过解引用指针 `ptr` 来访问数组的第三个元素，值为 `3`。

###### 2. 指针数组（Array of Pointers）
指针数组是一个数组，其元素是指针。数组的每个元素都是一个指针，可以指向不同的数据。

```plain
type *array[size];
```

+ `array` 是一个数组，它包含 `size` 个元素，每个元素是指向 `type` 类型数据的指针。
+ 每个指针可以指向不同类型的数据。

```plain
int a = 10, b = 20, c = 30;
int *arr[3];  // arr 是一个包含 3 个指针的数组
arr[0] = &a;
arr[1] = &b;
arr[2] = &c;

printf("%d\n", *arr[1]);  // 输出 20，因为 arr[1] 指向变量 b
```

+ 这里 `arr` 是一个指针数组，包含 3 个指针，分别指向 `a`、`b` 和 `c`。
+ `*arr[1]` 解引用 `arr[1]`，获取指向 `b` 的值，输出 `20`。

| 特性 | 数组指针 | 指针数组 |
| --- | --- | --- |
| 定义方式 | `type (*pointer)[size]` | `type *array[size]` |
| 指针指向 | 指向一个数组 | 指向多个不同的对象（每个元素是一个指针） |
| 使用场景 | 当你需要指向一个固定大小的数组时使用 | 当你需要保存多个指针时使用 |


这两者的主要区别在于指针的类型及其所指向的对象不同：数组指针指向一个固定大小的数组，而指针数组则是一个包含多个指针的数组。



函数指针：

函数指针是指向函数的内存地址的指针，就像普通指针指向数据的内存地址一样。通过函数指针，你可以像调用普通函数一样调用指针所指向的函数。

```plain
#include <stdio.h>

// 普通函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 定义一个函数指针，并将其指向 add 函数
    int (*func_ptr)(int, int) = &add;

    // 使用函数指针调用函数
    int result = func_ptr(3, 5);  // 相当于调用 add(3, 5)
    printf("Result: %d\n", result);  // 输出 Result: 8

    return 0;
}

```

+ 回调函数 将函数的地址传递给其他函数，以便在适当的时候调用。
+ 实现函数映射表 在一些需要根据条件运行不同函数的场景，可以使用函数指针实现函数映射表
+ 多态实现  虚函数和函数指针结合使用  可以实现类似于多态的效果。

#### static关键字
修饰局部变量：静态存储区（全局数据区）分配内存；⾸次函数调⽤中初始化，之后的函数调⽤不再初始化；函数内部可见，生命周期延长到整个程序执行过程。

修饰全局变量：静态存储区（全局数据区）分配内存；文件内可见，文件外不可见。

修饰函数：整个⽂件可以，⽂件外不可⻅；避免函数同名冲突（static修饰函数的弊端：仅在本⽂件内可⻅）

修饰成员变量：所有对象共享；类外初始化；不需要对象实例化就可以访问

修饰成员函数：所不能访问⾮静态成员（变量，不能调⽤⾮静态成员函数）原因是不能接受this指针，与任何对象⽆关；只能访问静态成员；不需要对象实例化就可以访问

C和C++中的区别：C只能修饰局部变量和全局变量、函数，C++还能修饰成员变量和成员函数

#### inline内联函数和普通函数的区别
普通函数的调用有函数调用开销。（描述）

inline内联函数：在编译过程中，在函数的调用点直接把函数的代码进行展开处理，

inline函数不再生成相应的函数符号，就没有函数调用的开销了，

如果函数较小，并大量调用，可以设置成内联函数。



不是所有的inline都会被编译器处理成内联函数（如递归）。inline只是建议编译器把函数处理成内联函数，最终还是由编译器决定。

debug版本上inline是不起作用的，inline只有在release版本下才会出现

优：

调⽤地⽅展开，省去调⽤时间，提⾼效率

相⽐#define宏函数，代码展开时会进⾏语法安全检查或数据类型转换，更加安全

缺：

代码膨胀，开销⼤

如果内联函数本⾝执⾏时间⻓，效率提升⼩

修改内联函数，所有调⽤内联函数的⽂件必须重新编译



#### 变量的声明和定义区别
声明：不分配地址；可以多个地⽅声明

定义：分配地址和存储空间；只能定义⼀次

extern int a：修饰的是变量的声明，此变量将在⽂件外/后⾯进⾏定义



#### 宏定义#define
定义表示  定义常量  定义函数  简化代码

+ 宏是简单的文本替换，不会进行类型检查，容易引入错误。
+ 在预处理阶段起作用
+ 如果宏定义不当（如未正确使用括号），可能会导致意外的运算优先级问题。



#### define和const区别
编译器处理⽅式不同：#define是预处理阶段展开；const是编译阶段使⽤

类型和安全检查不同：#define没有类型，不做任何检查；const编译阶段会执⾏检查

存储⽅式不同：#define代码展开，多个地⽅进⾏替换，不会分配内存；const分配内存，只维持⼀份拷⻉

定义域不同：#define不受定义域限制；const只在定义域内有效

#### typedef和define的区别
![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250225172448719.png)

#### extern
告诉编译器存在⼀个变量/函数，在⽂件的后⾯/其他的⽂件中定义

常用于跨文件共享全局变量和函数声明。

#### extern"C"
它的主要作用是告诉C++编译器，被声明的函数或变量使用C语言的链接规则，而不是C++的链接规则。

C不⽀持函数重载，编译函数时不会带上函数的参数类型，⼀般只包括函数名

C++⽀持函数重载，编译函数时会带上函数的参数类型

使⽤场景：C++代码调⽤C语⾔代码；多个⼈协同开发

只有c++编译器才能识别extern"C"，所以extern"C"都是用在c++文件里面



只要是c++编译器，都内置了_cplusplus这个宏名

所以下面的代码：在c和c++编译器都是能正常编译的，但是古国只写个extern"C"，在c里面是没办法编译的

```plain
#ifdef __cplusplus
extern "C"
{
#endif
    int sum()
    {
        return 7;
    }
#ifdef _cplusplus
}
#endif
```

在c++里面就会定义了这个宏名 ，会执行extern"C"

在c里面没有定义这个宏名，不会执行extern"C"



#### 防⽌C++头⽂件被重复引⽤？
#ifndef

#program once

#ifndef兼容性更好，⽼的编译器不⽀持#program once



#### 程序内存地址空间
![进程虚拟地址空间.drawio](C:\Users\wangyupeng\Downloads\进程虚拟地址空间.drawio.png)

![](https://i-blog.csdnimg.cn/blog_migrate/2f4e58999b64c4b20b68919d2273f4ca.jpeg)













#### new和malloc的区别
申请位置  是否自动计算内存  是否调用构造析构函数  申请成功失败的返回  对数组的处理  是否可以相互调用

是否可以被重载  malloc可以直观的重新分配内存/扩充空间  

![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250226115727785.png)



#### delete和delete[]有什么区别？
先调⽤析构函数再释放内存

delete对单个对象调⽤析构函数，delete[]对每个对象逐个调⽤析构函数

简单类型没有析构函数，delete/delete[]⼀样；类对象⽤delete，类对象数组⽤delete[]

（否则第⼀个之后的对象都不调⽤析构函数）

new/delete、new[]/delete[] 要配套使⽤



#### new和delete是怎么实现的
```plain
Complex *pc;
void* mem = operator new( sizeof(Complex) ); //分配內存
pc = static_cast<Complex*>(mem); //轉型
pc->Complex::Complex(1,2);
```

首先调用operator new库函数，分配内存。operator new内部会调用malloc

然后把内存进行强制类型转换

然后调用对象的构造函数

最后返回指向新内存并已经构造后的对象的指针



```plain
Complex::~Complex(pc); // 析構函數
operator delete(pc); // 釋放內存
```

首先调用对象的析构函数

然后调用operator delete标准库函数，释放内存。operator delete内部会调用free



#### 既然已经有了malloc free  为什么还要有new delete
为了更好的支持c++的面向对象特性。

new delete会调用对象的构造函数  析构函数。

malloc free只是分配空间，回收空间。

C语言并没有构造函数 析构函数的概念，所以malloc free的设计并没有包含这些功能。

malloc free是库函数，是编译哈好的二进制代码，没有办法把构造  析构强加给malloc free



#### 被free回收的内存会立即返还给操作系统吗
会首先被内存管理器用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时内存管理器也会尝试对小块内存进行合并，避免过多的内存碎片。





#### 内存泄漏
**内存泄漏**（Memory Leak）是指程序在运行过程中分配了内存，但在使用完这些内存后没有正确地释放它们，导致无法再访问或使用这些内存，最终导致程序所占用的内存不断增加，直到系统内存耗尽。

**内存资源浪费**：被泄漏的内存无法被其他程序或系统使用，最终导致程序的内存占用越来越大。

**系统崩溃或性能下降**：内存泄漏会导致程序占用越来越多的内存，可能最终导致系统崩溃或者程序运行变慢，特别是在长时间运行的程序中，内存泄漏会非常明显。

**忘记释放内存**：使用 `malloc` 或 `new` 分配内存后，忘记调用 `free` 或 `delete` 来释放内存。

```plain
int* p = new int;
// 使用 p
// 忘记 delete p; 这就会导致内存泄漏
```

**多次分配，旧的内存无法释放**：有时候，程序会多次为同一指针分配内存，但在新的内存分配之前没有先释放旧的内存，导致旧的内存丢失引用，从而发生内存泄漏。

```plain
int* p = new int;
p = new int; // 原先的内存没有释放，导致内存泄漏
```

**异常导致内存未释放**：如果在分配内存后发生异常且没有进行适当的异常处理，那么分配的内存也不会被释放，造成内存泄漏。

```plain
int* p = new int;
// 程序中发生异常
// 如果没有适当的异常处理，p 指向的内存不会释放
```

**循环引用**：对于使用引用计数的智能指针（例如 `std::shared_ptr`），如果对象之间相互引用，可能会导致引用计数永远不为零，内存永远不会被释放。



**valgrind**

valgrind --leak-check=full ./test  可以进行内存泄漏的检查



<font style="background-color:#f3bb2f;">2728</font> HEAP SUMMARY:  
<font style="background-color:#f3bb2f;">2728</font>     **in use at exit: 40 bytes in 1 blocks**  
<font style="background-color:#f3bb2f;">2728</font>   total heap usage: 2 allocs, 1 frees, 72,744 bytes allocated  
<font style="background-color:#f3bb2f;">2728</font>   
<font style="background-color:#f3bb2f;">2728</font> 40 bytes in 1 blocks are definitely lost in loss record 1 of 1  
<font style="background-color:#f3bb2f;">2728</font>    **at 0x484A2F3: operator new[]**(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)  
<font style="background-color:#f3bb2f;">2728</font>    by 0x10919E: **main (in /home/wyp/valgrind/test)**





#### 指针和引用的区别
指针是一个变量，他的值是另一个变量的地址。

引用跟原来的变量本质上是同一个东西，只是变量的别名。

1 汇编层面上

 定义指针变量和定义引用变量在汇编指令上是一样的，

 通过引用变量修改所引用内存的值，和通过指针变量修改所指向内存的值，其底层指令也是一样的

在使用上

2 引用必须初始化 指针可以不初始化。指针可以为空，可以改变指向。而引用不能为空并且在定义时必须初始化，初始化后不能改变。

3 引用只有一级引用，没有多级引用

4 sizeof指针得到的是指针的大小。sizeof引用得到的是所引用变量的大小。

5 引用的使用更加方便，改变指针指向内存，需要使用解引用，而引用可以直接更改，不需要使用解引用。

总结：在汇编指令上是一样的，但是引用在语法和编译器层面增加了一些限制，使得引用更加方便、安全。

指针常用于动态内存分配，数组操作，以及函数参数传递

引用常用于函数参数传递 ，以及操作符重载  取别名。



#### 右值引用
左值：有内存 有名字 值可以修改

右值：没有内存，没有名字，不能取地址

右值引用专门用来引用右值类型，指令上，自动产生临时量，然后 引用临时量。

右值引用本身是一个左值，有内存，有名字。

不能用右值引用变量来引用左值











### cpp11
#### cpp11有哪些新特性？
智能指针shared_ptr、weak_ptr、unique_ptr

右值引⽤

语法：auto、for、nullptr、decltype、constexpr

lambda表达式（匿名函数）

STL容器：array、forward_list、unordered_map/set、

多线程：thread、atomic、lock_guard、mutex、condition_variable（条件变量）、sem_t（信号量）

函数：function、bind



#### 智能指针
C++引入了智能指针，方便管理堆内存。使用普通指针，容易发生内存泄露，二次释放，程序发生异常时的内存泄漏等。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。包含shared_ptr,unique_ptr,weak_ptr。

shared_ptr：共享智能指针，共享对象所有权，通过引用计数管理资源，适合多个对象共享同一资源的场景。

shared_ptr实现原理：采用**引用计数器**的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

+ 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
+ 每次创建类的新对象时，初始化指针并将引用计数置为1
+ **拷贝构造函数**拷贝指针并增加与之相应的引用计数
+ 对一个对象进行**赋值**时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
+ 调用**析构函数**时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）



初始化

```cpp
shared_ptr<int> ptr1(new int(10));
cout << "引用计数：" << ptr1.use_count() << endl;
//拷贝构造
shared_ptr<int> ptr2(ptr1);
cout << "引用计数：" << ptr1.use_count() << endl;
shared_ptr<int> ptr3 = ptr2;;
//移动构造
shared_ptr<int> ptr4 = std::move(ptr1);
//make_shared
shared_ptr<int> ptr5 = make_shared<int>(5);
```

reset方法

```cpp
ptr4.reset();//指针置空

ptr5.reset(new int(250));//对指针进行初始化
```

获取原始指针

```cpp
int len = 128;
shared_ptr<char> ptr(new char[len]);
// 得到指针的原始地址
char* add = ptr.get();
memset(add, 0, len);
strcpy(add, "我是要成为海贼王的男人!!!");
cout << "string: " << add << endl;
```

##### 手写shared_ptr
```cpp
#include <iostream>

template <typename T>
class SharedPtr {
private:
    T* ptr;           // 指向实际资源
    int* ref_count;   // 引用计数

public:
    // 构造函数
    explicit SharedPtr(T* p = nullptr) : ptr(p), ref_count(new int(1)) {}

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other) {
        ptr = other.ptr;
        ref_count = other.ref_count;
        ++(*ref_count);
    }

    // 赋值运算符
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release(); // 释放原资源
            ptr = other.ptr;
            ref_count = other.ref_count;
            ++(*ref_count);
        }
        return *this;
    }

    // 析构函数
    ~SharedPtr() {
        release();
    }

    // 释放资源函数
    void release() {
        if (--(*ref_count) == 0) {
            delete ptr;
            delete ref_count;
        }
    }

    // 解引用操作符
    T& operator*() const { return *ptr; }

    // 成员访问操作符
    T* operator->() const { return ptr; }

    // 获取引用计数
    int use_count() const { return *ref_count; }
};

```





##### RAII编程思想
unique_ptr独占式拥有，同⼀时间只有⼀个智能指针可以指向该对象，适合独占资源的场景；不能进⾏拷⻉构造和拷⻉赋值（拷贝结束后，两个指针指向同一空间，有重复释放的问题），可以进⾏移动构造和移动赋值，原来的被置为nullptr。

用法

```cpp
//构造函数
unique_ptr<int> p1(new int(6));
//移动构造
unique_ptr<int> p2 = move(p1);
//reset
p2.reset();

//获取原始指针
int * p = p2.get();
```





weak_ptr：对对象的弱引⽤。指向一个shared_ptr管理的对象，weak_ptr只是提供了对管理对象的一种访问手段。不会增加或减少对象的引⽤计数，搭配shared_ptr使⽤；只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造；



shared_ptr使用注意事项：

+ 不能使用原始地址初始化多个shared_ptr共享智能指针
+ 函数不能返回管理了this的共享智能指针对象
+ 共享智能指针不能循环引用









两个作用：

1 使用weak_ptr解决循环引用问题：

循环引用问题主要出现在使用shared_ptr时，当两个或多个对象相互持有对方的shared_ptr，形成环的情况。导致它们的引用计数无法归零，从而引发内存泄漏。

• weak_ptr的作用：不增加引用计数，仅观察对象，不管理生命周期。 
• 打破循环：将其中一个shared_ptr改为weak_ptr，避免循环依赖。

```cpp
struct TA
{
    shared_ptr<TB> bptr;
    ~TA()
    {
        cout << "class TA is disstruct ..." << endl;
    }
};

struct TB
{
    weak_ptr<TA> aptr;
    ~TB()
    {
        cout << "class TB is disstruct ..." << endl;
    }
};

void testPtr()
{
    shared_ptr<TA> ap(new TA);
    shared_ptr<TB> bp(new TB);
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

    ap->bptr = bp;
    bp->aptr = ap;
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;
}
```

用法：

[https://subingwen.cn/cpp/weak_ptr/](https://subingwen.cn/cpp/weak_ptr/)

2 

C++11中为我们提供了一个模板类叫做std::enable_shared_from_this，这个类中有一个方法叫做shared_from_this()，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用weak_ptr来监测this对象，并通过调用weak_ptr的lock()方法返回一个shared_ptr对象。





#### 右值引用 移动构造 完美转发
左值右值：

左值是指**存储在内存中、有明确存储地址（可取地址）**的数据；

右值是指**可以提供数据值**的数据（不可取地址）；

**看能不能对表达式取地址，如果能，则为左值，否则为右值**。

右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue）：

纯右值：非引用返回的临时变量、运算表达式（如1+2）产生的临时变量、原始字面量和 lambda 表达式等  
将亡值：与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等。





右值引用：延长对象生命周期：右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。





右值引用：支持移动语义：在C++11之前，所有的对象传递通常是拷贝（深拷贝），会浪费大量资源。右值引用允许对象资源从一个对象“移动”到另一个对象，避免不必要的深拷贝，提高性能。（通过移动构造函数实现）。

移动语义是一种资源转移的机制，允许对象**接管另一个对象的资源**，而不是进行昂贵的深拷贝，从而提高程序性能。

在进行赋值操作的时候如果=右边是一个右值，那么移动构造函数就会被调用。移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。

如果**右侧是右值**，那么：

+ **构造时**，会优先调用**移动构造函数**（如果存在）。
+ **赋值时**，会优先调用**移动赋值运算符**（如果存在）。
+ 如果**没有移动构造或移动赋值运算符**，则会退化为**拷贝构造或拷贝赋值运算符**。

std::move 的作用是将一个左值转换为右值，从而触发移动构造或移动赋值。它不会真正地移动对象，而是标记对象为右值，以便调用移动语义函数（如 A(A&&) 或 A& operator=(A&&)）。



完美转发：右值引用在传递过程中会变成左值引用。（通过右值引用初始化右值引用，或者对右值引用进行函数参数的传递，右值应用会被看成左值引用）

```cpp
#include <iostream>
using namespace std;

void printValue(int &i)
{
    cout << "l-value: " << i << endl;
}

void printValue(int &&i)
{
    cout << "r-value: " << i << endl;
}

void forward(int &&k)
{
    printValue(k);
}

int main()
{
    int i = 520;
    printValue(i);
    printValue(1314);
    forward(250);

    return 0;
};
```

输出：

l-value: 520  
r-value: 1314  
l-value: 250//右值引用在传递过程中被看成了左值引用。

右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的std::forward()函数，该函数实现的功能称之为完美转发。

当T为左值引用类型时，t将被转换为T类型的左值 
当T不是左值引用类型时，t将被转换为T类型的右值

完美转发**允许函数保持参数的左值/右值属性**，从而避免不必要的拷贝或移动。



#### 多线程相关：
##### Thread类
+ thread t(func, 520, "i love you");  构造函数 ：创建了子线程对象t，func()函数会在这个子线程中运行。后面跟的是参数
+ thread t1(func1);函数没有参数
+ get_id()  获取子线程的线程id
+ join() 通过子线程对象调用join()函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。
+ detach()  线程分离  在线程分离之后，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。但是主线程退出也会**一并销毁创建出的所有子线程**。

```cpp
#include<iostream>
#include<thread>
#include<ctime>
#include<string>
#include <unistd.h>
using namespace std;
void func(int num,string s){
    for (int i = 0; i < 10;i++){
        cout << "子线程t:" << this_thread::get_id() <<  "i = " << i << "num: " 
             << num << ", str: " << s << endl;
    }
}
void func1(){
    for (int i = 0; i < 10;i++){
        cout << "子线程t1:" << this_thread::get_id() <<  "i = " << i << endl;
    }
}
int main(){
    cout << "主线程的线程id:" << this_thread::get_id() << endl;
    thread t(func,520,"hhh");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
    //t.join();//主线程必须等到线程函数执⾏完之后才会结束
    //t1.join();
    t.detach();//在线程分离之后，主线程退出也会一并销毁创建出的所有子线程.
    //在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，
    //这个子线程会自动释放自己占用的系统资源。
    t1.detach();
    sleep(1);
}
```

+ joinable() 
+ joinable()函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void foo()
{
    this_thread::sleep_for(std::chrono::seconds(1));
}

int main()
{
    thread t;
    cout << "before starting, joinable: " << t.joinable() << endl;

    t = thread(foo);
    cout << "after starting, joinable: " << t.joinable() << endl;

    t.join();
    cout << "after joining, joinable: " << t.joinable() << endl;

    thread t1(foo);
    cout << "after starting, joinable: " << t1.joinable() << endl;
    t1.detach();
    cout << "after detaching, joinable: " << t1.joinable() << endl;
}
```

输出：before starting, joinable: 0  
after starting, joinable: 1  
after joining, joinable: 0  
after starting, joinable: 1  
after detaching, joinable: 0在创建的子线程对象的时候，如果**没有指定任务函数**，那么子线程不会启动，主线程和这个子线程也**不会**进行连接  
在创建的子线程对象的时候，如果**指定了任务函数**，子线程启动并执行任务，主线程和这个子线程**自动连接成功**  
子线程调用了**detach()函数**之后，父子线程分离，同时**二者的连接断开**，调用joinable()**返回false**  
在子线程调用了**join()函数**，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就**断开**了，因此，调用join()之后再调用joinable()会**返回false**。

+ 静态函数
+ thread线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程，每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的。



```cpp
int num = thread::hardware_concurrency();
cout << "CPU number: " << num << endl;
```

##### 命名空间this_thread
[https://subingwen.cn/cpp/this_thread/](https://subingwen.cn/cpp/this_thread/)

+ get_id()  
调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID
+ sleep_for() 线程会马上从运行态变成阻塞态并在这种状态下休眠一定的时长
+ sleep_until()：指定线程阻塞到某一个指定的时间点time_point类型，之后解除阻塞
+ yield() 线程调用了yield()之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。std::this_thread::yield() 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降  
std::this_thread::yield() 是让当前线程主动放弃了当前自己抢到的CPU资源，但是在下一轮还会继续抢

##### call_once函数   保证某⼀函数在多线程环境中只调⽤⼀次
```cpp
once_flag g_flag;
void do_once(int a, string b)
{
    cout << "name: " << b << ", age: " << a << endl;
}

void do_something(int age, string name)
{
    static int num = 1;
    call_once(g_flag, do_once, age, name);
    cout << "do_something() function num = " << num++ << endl;
}

int main()
{
    thread t1(do_something, 20, "ace");
    thread t2(do_something, 20, "sabo");
    thread t3(do_something, 19, "luffy");
    t1.join();
    t2.join();
    t3.join();

    return 0;
}
```

call_once(g_flag, do_once, age, name);

g_flag：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到  
do_once：只能调用一次的回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数  
后面跟的都是参数

##### mutex
```cpp
mutex g_num_mutex;
void func(int id)
{
    for (int i = 0; i < 50;i++){
        g_num_mutex.lock();
        g_num++;
        cout << id << "=>" << g_num << endl;
        g_num_mutex.unlock();
        sleep(1);
    }
}
```

mutex的用法



**lock_guard**在构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。lock_guard使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。

```cpp
void func(int id)
{
    for (int i = 0; i < 50;i++){
        //g_num_mutex.lock();
        lock_guard<mutex> lock(g_num_mutex);
        g_num++;
        cout << id << "=>" << g_num << endl;
        //g_num_mutex.unlock();
        //sleep(1);
    }
}
```



+ std::recursive_mutex  
递归互斥锁std::recursive_mutex允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题
+ std::timed_mutex  
std::timed_mutex是超时独占互斥锁，主要是在获取互斥锁资源时**增加了超时等待功能**，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。

##### 条件变量和unique_lock：
+ `std::unique_lock` 是条件变量的推荐锁管理器，因为它支持在等待时释放锁，并在唤醒时重新获取锁。
+ 示例：

```cpp
std::condition_variable cv;
std::mutex mtx;
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock);  // 等待条件变量
```

```cpp
wait()：阻塞等待的同时释放锁
notify_all()：唤醒所有阻塞的线程
notify_one()：唤醒某⼀个等待的线程
```



条件变量和unique_lock配合使用

```plain
void put(const int& x)
    {
        unique_lock<mutex> locker(m_mutex);
        // 判断任务队列是不是已经满了
        while (m_queue.size() == m_maxSize)
        {
            cout << "任务队列已满, 请耐心等待..." << endl;
            // 阻塞线程
            m_notFull.wait(locker);
        }
        // 将任务放入到任务队列中
        m_queue.push_back(x);
        cout << x << " 被生产" << endl; 
        // 通知消费者去消费
        m_notEmpty.notify_one();
    }

    int take()
    {
        unique_lock<mutex> locker(m_mutex);
        while (m_queue.empty())
        {
            cout << "任务队列已空，请耐心等待。。。" << endl;
            m_notEmpty.wait(locker);
        }
        // 从任务队列中取出任务(消费)
        int x = m_queue.front();
        m_queue.pop_front();
        // 通知生产者去生产
        m_notFull.notify_one();
        cout << x << " 被消费" << endl;
        return x;
    }
```

根据linux下条件变量的机制，condition_variable在wait成员函数内部会先调⽤参数

unique_lock的unlock临时解锁，让出锁的拥有权（以让其它线程获得该锁使⽤权加

锁，改变条件，解锁），然后⾃⼰等待notify信号，等到之后，再调⽤参数

unique_lock的lock加锁，处理相关逻辑，最后unique_lock对象销毁时⾃动解锁。

##### lock_guard和unique_lock的区别
+ `std::lock_guard`：
    - **自动获取锁**：在构造时立即获取锁，并在析构时自动释放锁。
    - **不可手动控制**：没有提供手动获取或释放锁的方法，锁的生命周期完全由对象的生命周期决定。
    - **简单易用**：适用于简单的场景，确保在作用域结束时自动释放锁，避免忘记释放锁导致的死锁。
+ `std::unique_lock`：
    - **灵活的锁管理**：可以在构造时选择是否立即获取锁（通过 `std::defer_lock` 或 `std::try_to_lock`），也可以在后续手动获取或释放锁。
    - **手动控制锁**：提供了 `lock()` 和 `unlock()` 方法，允许在需要时手动获取或释放锁。
    - **更复杂**：适用于需要更细粒度控制锁的场景，但使用不当可能导致死锁或资源泄漏。
+ `std::lock_guard`：
    - **适用场景**：适用于简单的锁管理，确保在作用域结束时自动释放锁。适合不需要条件变量或超时等待的场景。
    - **优点**：简单易用，避免死锁风险。
    - **缺点**：功能有限，无法手动控制锁的获取和释放。
+ `std::unique_lock`：
    - **适用场景**：适用于需要更灵活的锁管理的场景，如条件变量、超时等待或递归锁。
    - **优点**：功能强大，支持手动控制锁的获取和释放。
    - **缺点**：使用复杂，需要谨慎管理锁的生命周期，否则可能导致死锁或资源泄漏。



##### 原子操作atomic
在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。因为对原子变量进行的操作只能是一个原子操作（atomic operation），原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换。

```plain
std::atomic<int> atomicCounter(0);  // 原子整数，初始值为0
std::atomic<bool> atomicFlag(false);  // 原子布尔变量
```

`std::atomic` 提供了多种原子操作方法，包括：

+ **读取值**：使用 `.load()` 方法。
+ **写入值**：使用 `.store()` 方法。
+ **自增/自减**：使用 `++`、`--` 或 `.fetch_add()`、`.fetch_sub()`。

##### lambda表达式
##### 范围for循环：
##### 其他：慢慢总结吧
### STL标准模板库
##### STL包含哪些组件
容器：数据的存放形式，序列式容器、关联式容器

算法：用于处理容器中的数据，如排序、复制等。以及不同容器特定的算法。

迭代器：不暴露容器内部结构的情况下对容器进行遍历

仿函数：重载了函数调用运算符（`operator()`）的类对象，可以像普通函数一样使用。

适配器：基于现有容器类的简化接口，用于提供特定的数据结构行为。它们本身并不直接管理数据，而是通过封装底层容器来实现特定的功能。栈、队列、优先级队列

空间配置器：用于管理内存分配和释放的组件。

#### vector
##### 底层实现
vector在堆中分配了一片连续的内存空间来存放元素。

三个迭代器：

```plain
start   //目前使用空间的头
finish  //目前使用空间的尾
end_of_storage    //目前可用空间的尾
```

![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250307165809007.png)

##### vector中size和capacity区别
size：当前有多少元素（finsh - start）

capacity：当前存储空间能容纳多少元素（end_of_storage - start）

##### vector中reserve和resize区别？
reserve：功能：只改变容器的容量（即 capacity()），而不改变其大小（size()）。（容量只增不减）

resize：功能：直接修改容器的大小（即 size()）。  
行为：  
■ 如果指定的新大小大于当前大小，容器会扩展，并用默认值（或指定值）填充新元素。  
■ 如果指定的新大小小于当前大小，容器会删除多余的元素。

##### 扩容机制
当 size() == capacity() 时，向 vector 添加新元素会触发扩容。

扩容时，vector 需要：

1. 分配更大容量的内存块（通常是当前容量的 2 倍，但具体倍数可能由标准库实现决定）。
2. 将旧数据移动到新内存块（如果元素是 TriviallyCopyable，则使用 memcpy，否则调用移动/拷贝构造）。
3. 释放旧内存。



固定扩容：空间利用率高。扩容次数会相应增加。

两倍扩容：空间利用率不如固定扩容高。但是翻倍扩容使得正常情况下添加元素需要的扩容次数大大减小。

两倍是减少扩容次数和提高内存利用率折中之下的选择。



##### vector如何释放空间？
vector删除元素内存不释放，析构时候才全部释放，clear()也是清空但不删除

空间动态缩⼩，考虑deque

使⽤swap  vector (v1.begin(), v1.end()).swap(v1);

使用shrink_to_fit()    **只是请求缩小容量，标准库不保证一定会释放内存**。

##### vector使迭代器失效的情况？
+ erase()：删除位置之后的迭代器、指针、引⽤失效

推荐：erase使用返回值：it = vec.erase(it);  // 指向下一个有效元素

+ insert()：

插⼊引起扩容，全部失效

没有引起扩容，插⼊位置之后的迭代器失效

+ 当 `vector` 发生扩容（reallocation）时，所有迭代器都会失效。

push_back()    insert()    resize()可能引起扩容



##### push_back的时间复杂度
| 操作 | 时间复杂度 |
| --- | --- |
| **普通 **`push_back()` | O(1) |
| **扩容时的 **`push_back()` | O(N) |
| **摊销后的 **`push_back()` | O(1) |


#### deque
![](http://oss.interviewguide.cn/img/202205220021322.png)

简单介绍：

vector是单向开口（尾部）的连续线性空间，deque（双端队列）则是一种**双向开口的连续线性空间**。

deque和vector的最大差异一个是**deque在常数时间内对头端进行元素操作**，二是**deque没有容量的概念**，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来

deque由**一段一段的定量连续空间组成**，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性

虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）

内部组成：

deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示。



迭代器：

![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250307210622747.png)

维护start和finish两个迭代器，每个迭代器四部分：cur、first、last、node

++  --  操作需要判断是否到了缓冲区头/尾

插⼊、删除操作为了提⾼效率，会判断元素偏前还是偏后，偏前移动前⾯的元素





#### list
![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250307202056342.png)

list:底层是双向环状链表，插入或删除都只作用于一个元素空间，对任何位置元素的插入和删除都是常数时间。

list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。

迭代器失效：插入(insert)和接合(splice)操作都不会造成迭代器失效。删除(erase)操作只会使指向被删除元素的迭代器失效。



#### 关于stack和queue
**stack和queue都可以选择list和deque作为底层容器，默认是deque**

**stack可以选择vector作为底层结构**

**queue不可以选择vector作为底层结构。vector没有pop_front**    

注意：如果选择vector作为queue的底层结构，除了pop()操作，其他操作都可以正常运行

stack和queue都不可以选择set和map作为底层结构(set可以通过编译，但是操作无法进行,map不能通过编译)

#### map  set
##### map、set、multiset、multimap底层原理？
std::map 是一种关联容器，用于存储键值对（key-value pairs），并且按键的顺序自动排序。std::map 的底层实现是红黑树。

**底层数据结构是红⿊树**

节点不是⿊就是红

根节点是⿊⾊的

叶⼦节点都是空节点null、并且是⿊⾊的

红⾊节点的父节点和两个⼦节点都是⿊⾊节点（不能出现连续两个红色节点）

从任意节点到这个节点的叶⼦节点的路径都包括相同数量的⿊⾊节点（⿊⼦节点的数量称为⿊⾼）

从根节点到叶⼦节点的最⻓路径不⼤于最短路径的 2 倍：最短路径是全⿊⾊节点，最⻓路径（有红⾊节点必有⿊⾊节点，红⿊⾊节点数量相同时候，⻓度=⿊⾊或红⾊ * 2）

增删改查速度为logn

##### 底层为什么⽤红⿊树不⽤AVL树？
AVL平衡规则太过严格，插入删除容易破坏平衡状态，需要频繁调整树的形态。每次插入都要计算平衡因子，找到最小不平衡子树，时间开销大。

红黑树的插入删除操作效率更高。AVL适合读取查找型密集任务，红⿊树适合插⼊密集型任务

##### 为何map和set的插⼊删除效率⽐其他序列容器⾼，⽽且每次insert之后，以前保存的iterator不会失效？
存储的是节点，不需要内存拷⻉和内存移动

插⼊操作只是指针换来换去，节点内存没有改变

##### map的插入操作
使用insert插入存在的键，会插入失败，返回已经存在的键的迭代器

如果使用 [] 插入一个已存在的键，std::map 会**更新**该键对应的值，而不是插入一个新的键值对

##### map中find和[]的区别？
[]：找到key返回这个值；没找到key插⼊value

find()：找到返回该位置迭代器；没找到返回end()迭代器

##### map和vector中[]的区别？
vector中[]会做边界检查

map中[]找到返回，没找到插⼊

#### unordered_map  unordered_set底层
![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250310201742213.png)

unordered_map 的底层实现是一个**哈希表**，具体采用**开链法（链地址法）**来解决哈希冲突。其结构包括：  
• 哈希函数：用于将键（key）映射到一个桶（bucket）索引。  
• 桶数组：一个动态数组，每个桶存储一个链表，链表中存储键值对（std::pair<const Key, Value>）。  
• 负载因子：定义为哈希表中元素数量与桶数量的比值，用于衡量哈希表的负载程度。



##### 哈希冲突解决：
拉链法:

优点：无堆积现象    可以直接删除节点    动态性好

缺点：需要额外空间 链表过长时查找效率低。



线型探测法：

优点：实现简单    空间效率高（不需要额外空间）

缺点：堆积现象。不能直接删除节点。

其他解决哈希冲突方法：平方探测法，伪随机数探测法，再哈希法，建立公共溢出区



扩容机制：

unordered_map 的扩容机制是为了**保持哈希表的高效性，避免因负载过高导致查找性能下降。**

扩容操作通常在以下情况下触发：  
• 当负载因子（load factor）超过预设的阈值（默认为1.0）时  
• 负载因子 = 哈希表中元素数量 / 桶数量

1.**计算新的桶数量**：**两倍增长或者两倍附近的一个素数**

2. **分配新内存**：为新的桶数组分配内存
3. **重新哈希和迁移**：遍历旧桶数组中的所有元素，重新计算哈希值，并将它们迁移到新的桶数组中
4. **释放旧内存**：释放旧桶数组的内存
5. **更新内部状态**：更新桶数量、负载因子等内部状态





##### heap
make_heap()操作：

```cpp
std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5};
std::make_heap(vec.begin(), vec.end()); // 构建最大堆
```

push_heap操作：

```plain
vec.push_back(10); // 添加新元素
std::push_heap(vec.begin(), vec.end()); // 将新元素调整到堆中
```

pop_heap操作：

```plain
std::pop_heap(vec.begin(), vec.end()); // 将堆顶元素移动到末尾
vec.pop_back(); // 移除末尾元素
```

##### priority_queue
✅ **基于堆实现**（默认为**最大堆**）  
 ✅ **自动维护有序性**（每次 `top()` 返回最大/最小值）  
 ✅ **插入和删除的时间复杂度为 **`O(logN)`  
 ✅ **访问 **`top()`** 的时间复杂度为 **`O(1)`

接口：

| **接口** | **作用** | **时间复杂度** |
| --- | --- | --- |
| `push(value)` | 插入元素 | `O(logN)` |
| `pop()` | 删除堆顶元素 | `O(logN)` |
| `top()` | 获取堆顶元素（最大堆：最大值；最小堆：最小值） | `O(1)` |
| `empty()` | 判断是否为空 | `O(1)` |
| `size()` | 返回当前元素个数 | `O(1)` |
| `swap(other)` | 交换两个 `priority_queue` | `O(1)`（交换指针） |
| `emplace(value)` | 直接构造并插入元素（避免拷贝） | `O(logN)` |


#### 迭代器相关
##### 迭代器的种类？
input_iterator：只读，从⼀个对象中读出元素（==、!=、->、*）

output_iterator：只写，向⼀个对象中修改/添加（*i = v，++）

forward_iterator：读写、单向移动，⼀次⼀步（++）

bidirectional_iterator：读写、双向移动，⼀次⼀步（--）

random access iterator：所有操作，任意读写，还另外⽀持[i]

![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250310203140494.png)

##### 每种容器对应的迭代器类型：
![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250310203231457.png)



##### 迭代器怎么实现
1、 通过迭代器可以在**不了解容器内部原理的情况下遍历容器**，除此之外，STL中迭代器作为**容器与STL算法的粘合剂**。

2、相当于一个智能指针， 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部**必须保存一个与容器相关联的指针**，**然后重载各种运算操作来遍历**，其中最重要的是***运算符与->运算符，以及++、--等**可能需要重载的运算符重载。





##### STL迭代器失效的情况
unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.

stack、queue、priority_queue没有迭代器

扩容：内存重新分配全部失效

插⼊：vector、deque插入位置之后的迭代器失效，尾迭代器失效，list、forward_list、map、set插⼊操作不失效

删除：vector、deque删除位置之后的迭代器失效，list、forward_list、map、set仅删除位置迭代器失效

[https://juejin.cn/post/6971252856498159653](https://juejin.cn/post/6971252856498159653)



##### 如何在共享内存上使用STL标准库
为了在共享内存中使用 STL 容器，需要实现一个自定义分配器，使其能够从共享内存中分配和释放内存。

假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？  
一个方法就是进程A把容器放在共享内存中的**确定地址**上（fixed offsets），则进程B可以从该已知地址 上获取容器。

另外一个改进点的办法是，进程A先在共享内存**某块确定地址上放置一个map容器**，然后 进程A再创建其他容器，然后给其**取个名字和地址一并保存到这个map容器里**。进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。





##### 为什么要⽤deque作为stack和queue的底层默认容器？为什么默认不是vector或list
+ vector重新分配内存时，性能开销较大，空间利用率低。deque空间利用率高，内存不足时只需寻找定量的一段空间。
+ list每个节点需要额外存储指向前驱和后继节点的指针，这增加了内存开销

##### list与vector区别
`vector` 是一个**动态数组**，底层使用连续的内存空间来存储元素。可以随机存取。尾部插入删除O(1)，其他位置平均O（n）。空间不足时要进行扩容。空间利用率高。

`list` 是一个**双向链表**，每个元素存储为一个独立的节点，每个节点包含指向前一个节点和后一个节点的指针。不能随机存取，插入删除平均O(1)。空间利用率低。

#### sort实现
数据量大时采用快排算法**，分段快速排序。**

**一旦分段后的数据量小于某个门槛（16），就改用插入排序**。（插入排序在小规模数据上表现更好）

如果递归层次过深（1.5 log₂(N)），切换成堆排序。（**避免快速排序的退化问题**）。即使在最坏情况下，堆排序也能保证 **O(n log n)** 的时间复杂度，不会像快速排序那样出现性能大幅下降。

#### 堆
堆的性质

+ 必须是一颗完全二叉树
+ 大根堆（父 > 子）  小根堆（父 < 子）

存储（用数组）

一个节点i：它的左孩子2i+1   右孩子2i+2   父结点(i - 1)/2向下取整（下标从0开始） 父结点(i)/2向下取整（下标从1开始）





### OOP编程
#### 类对象的大小由哪些因素决定
+ 非静态成员变量（静态成员变量不依赖于对象）
+ 继承（对象大小叠加）。虚继承（引入虚基表指针）
+ 虚函数机制（引入虚函数表指针）
+ 内存对齐（编译器对齐，自定义对齐）



#### C和C++的struct有什么不同？
C不能有成员函数；C++可以有成员函数

C中没有private、public、protected访问限定符；C++中有

C中没有继承关系；C++中有继承关系





#### C++中struct和class的区别？
访问权限：struct默认public，class则默认private

继承：struct默认public继承，class则默认private继承

抽象层⾯：class像对象的实现体，struct是数据结构的实现体

struct不⽤于定义模板参数，class还能⽤于定义模板参数   template



#### 面向对象的三大特征
封装是指将对象的**数据（属性）和操作数据的方法（行为）**捆绑在一起，形成一个独立的对象（类），并隐藏对象的内部实现细节，只通过对象的接口（公共方法）与外界交互。

继承是指一个类（子类或派生类）可以继承另一个类（父类或基类）的属性和方法。子类继承了父类的成员变量和成员函数，并且可以添加新的成员变量和成员函数，或者覆盖父类的成员函数，以实现更具体的功能。

多态是指同一个接口（方法）可以被不同的实例以不同的方式实现。多态使得程序可以在运行时根据对象的实际类型调用相应的方法，从而实现更灵活的编程。

在C++中，运行时多态主要通过虚函数（virtual函数）实现。虚函数允许子类覆盖父类的成员函数，从而实现不同的行为。



#### 构造函数能抛出异常吗？
可以抛出，但尽量不要，会造成内存泄露



#### protected做了什么事情？
private成员只能被本类成员（类内）和友元访问，不能被派⽣类访问；

protected成员可以被派⽣类访问。

protected继承之后会改变继承来的成员的访问权限（public、protected-》protected）



#### 多态的分类以及实现：
静态多态/静态绑定：编译期间确定；函数重载、函数模板

动态多态/动态绑定：运⾏期间确定；虚函数+继承实现，基类指针/引⽤运⾏期间再决定使⽤哪个函数

#### 动态多态/动态绑定作⽤？必要条件？如何实现？
作用：

1. **提高代码的灵活性和可扩展性**：通过基类的统一接口，可以方便地扩展新的功能，而无需修改现有代码。
2. 实现代码复用
3. 降低代码耦合度



必要条件

1. **继承关系**：必须有基类和派生类的关系。
2. **虚函数（**`virtual`**）**：基类中需要声明虚函数，告诉编译器支持动态绑定。
3. **父类指针或引用**：必须通过基类的指针或引用操作派生类对象，直接使用对象调用不会触发动态绑定。

如何实现：

1. **声明虚函数**：在基类中使用`virtual`关键字声明成员函数。
2. **派生类重写虚函数**：派生类需要提供与基类虚函数同名、同参数、同返回类型的函数。
3. **通过基类指针或引用调用**：在运行时，通过基类的指针或引用指向派生类对象，并调用虚函数。

#### 重载隐藏
1 重载关系

  一组函数要重载，必须在同一作用域中，而且函数名字相同，参数列表不同



2 隐藏（作用域的隐藏）关系

  在继承结构当中 派生类的同名成员把基类的同名成员隐藏掉了。

#### 基类对象和派生类对象的转换
从下到上的转换  没有问题

发生对象切片现象。派生类对象被赋值给基类对象时，派生类对象的派生部分会被“切掉”，只保留基类部分



派生类对象到基类对象的转换

从上到下的转换  不可以



基类指针（引用）指向派生类对象

可以 只能访问基类部分的成员



派生类指针（引用）指向基类对象

不可以



在继承结构中  进行上下的类型转换  默认只支持从下到上的转换



#### 虚函数总结：
总结一;

如果类里面定义了虚函数，那么编译阶段 编译器需要给这个类类型产生一个唯一的vftable,

虚函数表中主要存储的内容就是RTTI信息和虚函数的地址。

当程序运行时每一张虚函数表都会加载到内存的.rodata区（只读数据区）



总结二：

一个类里面定义了虚函数，那么这个类定义的对象，其运行时，内存中开始部分，多存储一个vfptr虚函数指针，指向相应类型的虚函数表vftable，

一个类型定义的多个对象，他们的vfptr指向的都是同一张虚函数表



总结三：

一个类的虚函数个数，不影响对象内存大小，影响的是虚函数表的大小



总结四

如果派生类中的方法和基类继承来的某个方法返回值 函数名  参数列表都相同 

而且基类的方法是虚函数，那么派生类的这个方法自动处理成虚函数

覆盖：基类的方法是虚函数，并且派生类对基类的虚函数进行了重写，派生类的方法自动处理成虚函数，称为覆盖

#### 虚函数表
虚函数表中存的是虚函数指针，**⼦类覆盖时虚函数地址会被替换**







该类的所有对象共享类的虚函数表（虚函数表伴随类⽽不是对象），每个对象都必须保存⼀个指向虚函数表的vptr，vptr地址不同，但指向同⼀虚函数表

基类的虚函数表

![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250405215221724.png)

派生类的虚函数表



![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250405223733129.png)



#### 虚函数表和虚函数表指针的创建时间

虚函数表：

每个包含虚函数的类，在编译时都会生成一个虚函数表（vtable）；

这个表是一个全局静态数组，存放的是该类的虚函数指针；

存放在只读数据段中(.rodata)



虚函数表指针：

vptr 在 **构造函数执行前期由编译器自动设置**；

每个对象的起始地址处（对象的前几个字节）会有一个 **vptr**，指向该类的 vtable。









#### 哪些函数不能实现成虚函数
  1 虚函数需要依赖对象

  2 虚函数能产生地址存储在vftable中(对象存在-》vfptr-》vftable-》虚函数地址)



 构造函数：不能设计成虚函数（因为构造函数完成了才会产生对象，构造函数中调用任何函数都是静态绑定）

 派生类对象的构造过程：先调用的是基类的构造函数，才调用派生类的构造函数



- 原因：构造函数的主要作用是创建对象，但在对象创建过程中，虚函数机制尚未建立，虚表还未初始化。





类对象的前4个字节是虚函数表指针，构造之后才会⽣成，只有通过虚函数表才能调⽤虚函

数，⽽构造函数是虚函数

虚函数的意义在于通过⽗类指针调⽤⼦类成员函数，构造函数创建对象时候⾃动调⽤，不

可能通过⽗类指针调⽤



 static静态成员方法：不能设计成虚函数。static也不是依赖对象的。



#### 虚函数和动态绑定 问题：是不是虚函数的调用一定是动态绑定？不是的

静态绑定的场景：

 在类的构造函数当中，调用虚函数，也是**静态绑定**。（构造函数中调用其他函数，不会发生动态绑定）

 静态绑定 用对象本身调用虚函数，是**静态绑定**



动态绑定：

当满足以下三个条件时，**虚函数调用才会发生动态绑定**：

1. 函数是 `virtual`（即被声明为虚函数）；
2. 通过 **基类指针或引用** 调用；
3. 指向的是 **派生类对象**；

动态绑定 （必须由指针(引用)调用虚函数  才会发生动态绑定）

 基类指针指向基类  /  派生类  以及派生类指针指向派生类  都会发生动态绑定





#### 虚析构函数

析构函数是可以成为虚函数的（调用的时候对象存在）

什么时候把基类的析构函数必须实现成虚函数

基类的指针（引用）指向堆上new出来的派生类对象,它调用析构函数的时候必须发生动态绑定，否则会导致派生类的析构函数无法调用





#### 虚析构函数

虚析构函数是指：**在类中将析构函数声明为 `virtual` 的析构函数**，用来确保通过**基类指针删除派生类对象时能正确调用派生类的析构函数**，防止内存泄漏或资源未释放的问题。

如果没有将析构函数设为 `virtual`，当用基类指针删除派生类对象时，只会调用基类析构函数，派生类的资源无法释放，可能造成内存泄漏。

```plain
//Base类的析构函数没有被声明为虚函数。
//因此，当通过Base类的指针pb删除Derive类的对象时，只会调用Base类的析构函数，而不会调用Derive类的析构函数。
//Base类型  -》去看析构函数的类型-》不是虚函数-》静态绑定  只会调用基类的析构函数

//基类的析构函数是virtual  派生类的析构函数自动成为虚函数
//如果Base声明为虚函数，就会调用Derive的析构函数。
Base * pb = new Derive(10);
pb->show(111);
delete pb;//没有调用派生类的析构函数



//这里没有调用 delete pb;，d 是一个自动对象（栈对象），
//作用域结束时会自动调用析构函数。这时候 C++ 会自动调用 Derive 和 Base 的析构函数，
//析构是 按继承层次从派生类到基类依次调用，
// Derive d(10);
// Base * pb = &d;
// pb->show();
```

#### 抽象类和接口的区别
   抽象类是对类的抽象，接口是对行为的抽象。 抽象类用于指定共性，接口用于规范行为











#### 深拷贝浅拷贝
浅拷贝：

将原对象的**成员变量的值**直接复制到新对象中。如果成员变量是指针，那么指针的值（即地址）会被复制，而不是指针所指向的内容。

对象中有动态成员（指针）时候，析构时候会销毁两次，**内存重复释放的问题**

深拷贝：

深拷贝是指创建一个新对象时，不仅复制成员变量的值，还会为动态内存分配新的空间，并将原对象的动态内存内容复制到新分配的空间中。这样，新对象和原对象各自拥有独立的动态内存。



#### 拷⻉构造函数、赋值运算符区别？
拷⻉构造函数：构造新的对象

赋值运算符：将源对象的内容拷⻉到⽬标对象



#### 纯虚函数
在基类中没有具体的实现，而是要求派生类必须提供自己的实现。纯虚函数的主要作用是为**派生类定义一个接口规范**，确保派生类必须实现这些函数。

纯虚函数支持运行时多态，通过基类的指针或引用调用派生类的具体实现。

virtual void f() = 0

#### 抽象类
抽象类和普通类有什么区别

**拥有纯虚函数的类叫做抽象类！**

抽象类不能再实例化对象，但是可以定义指针和引用变量



一般把什么类设计成抽象类

一般把基类设计成抽象类,把保留的接口设计成纯虚函数，不提供实现



#### 虚函数表
虚函数表中存的是虚函数指针，⼦类覆盖时虚函数地址会被替换

虚函数表实际上就是⼀个函数指针数组，有的编译器⽤的是链表。虚函数表数组中的每⼀个元素对应⼀个函数指针指向该类的⼀个虚函数。

同时该类的每⼀个对象都会包含⼀个虚函数表指针，虚函数表指针指向该虚函数表的地址。所以当⼀个类有虚函数的，是占⽤内存的，占⽤⼀个指针⼤⼩的内存

该类的所有对象共享类的虚函数表（虚函数表伴随类⽽不是对象），每个对象都必须保存⼀个指向虚函数表的vptr，vptr地址不同，但指向同⼀虚函数表



#### 如何让⼀个类不能被实例化？
定义为抽象类（存在纯虚函数）

构造函数声明为private



#### 析构函数可以抛出异常吗
析构函数主要的职责是“清理资源”，比如释放内存、关闭文件、断开连接等。如果在析构时抛出异常，这些清理操作就不再可靠，容易造成资源泄露或程序崩溃。



#### 类和类之间的关系
组合：a part of  一部分的关系

继承：a kind of  一种的关系



组合的好处：被包含对象的内部细节对外不可⻅，封装性好



#### 多继承 菱形继承存在的问题
多继承二义性：

当多个父类中有相同名称的成员（函数或变量）时，子类中使用这个成员会不明确。

解决：

可以用**作用域**指定你想用的是哪一个父类的成员



菱形继承

当一个类从两个父类继承，而这两个父类又继承自同一个祖先类，会造成**重复继承**，导致数据冗余、二义性。

解决：

虚继承，虚继承会让子类共享唯一的一份基类子对象，从而消除重复。

```
class A {
public:
    int value;
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
```



#### 重载 隐藏 重写
![](C:\Users\wangyupeng\AppData\Roaming\Typora\typora-user-images\image-20250407154548790.png)





#### c++语言层面的四种强制类型转换
const_cast  去掉常量属性的类型转换



static_cast 能够提供编译器认为安全的类型转换(没有任何联系的类型之间的转换会被否定)c不管有没有联系 会直接转换。（编译时期的类型转换）



reinterpret_cast   类似于c风格的强制类型转换（谈不上什么安全）



dynamic_cast（运行时类型转换，支持RTTI类型识别）

通常⽤于多态类型转换；借助RTTI进⾏类型转换

向上向下转换均可，向上转型始终安全（因为基类有虚函数），向下时有类型检查功能

指向派⽣类的基类指针转换为派⽣类的指针或引⽤； Child *pchild =dynamic_cast<Child *>(pfather);

转换失败：指针转换失败返回NULL；引⽤转换失败抛出bad_cast异常



#### RTTI
RTTI的实现依赖于类的虚函数表（vtable）。包含虚函数的类有虚函数表，类对象有指向虚函数表的指针。虚表的第一个指针指向一个RTTI结构，存储该类的运行时类型信息。这个RTTI结构包含了`typeid`需要的类型名称，以及`dynamic_cast`进行类型转换检查所需的信息。

`dynamic_cast`操作符用于在多态类层次结构中，将基类指针或引用安全地转换为派生类指针或引用。如果转换失败，返回`nullptr`（对于指针）或抛出异常（对于引用）。



#### final和override关键字
如果使用final修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了（一般不是用于父类的虚函数，而是用于子类的虚函数，防止孙子类重写）

使用final关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。



override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也**明确表明将会重写基类的虚函数**，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会**提示语法错误**。





#### sizeof⼀个空类的值为多少/空类⼤⼩
这是因为每个对象必须有唯一的内存地址，所以空类的大小至少为1字节。这是为了确保每个对象都有一个唯一的this指针。



#### 空类有哪些成员函数？
构造函数

拷⻉构造函数

赋值运算符

析构函数

















